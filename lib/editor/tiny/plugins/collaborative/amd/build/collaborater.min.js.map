{"version":3,"file":"collaborater.min.js","sources":["../src/collaborater.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Storage helper for the Moodle Tiny Autosave plugin.\n *\n * @module      tiny_autosave/autosaver\n * @copyright   2022 Andrew Lyons <andrew@nicols.co.uk>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n//import * as Options from './options';\n//import * as Storage from './storage';mm\n//import Log from 'core/log';\n//import {eventTypes} from 'core_form/events';\n//import {getLogSource} from './common';\nimport * as jsDiff from './jsdiff/index';\nimport {call} from 'core/ajax';\nimport * as Options from \"./options\";\n\n\nlet currentContent = '';\nlet currentHash = '';\nlet newHash = '';\n//let newContent = '';\n//let lastHash = '';\nconst INTERVALTIMEOUT = 1000;\nconst HEADER = \"Index: a\\n===================================================================\\n\";\nconst COLCURSPAN = '<span id=\"COLCUR\"></span>';\nconst COLCURID = '#COLCUR';\nconst COLCURPLACEHOLDER = String.fromCharCode(254);\n\nconst fetchOne = (methodname, args) => call([{\n    methodname,\n    args,\n}])[0];\nlet intervalId = null;\n\nasync function sha1(message) {\n    const encoder = new TextEncoder();\n    const data = encoder.encode(message);\n    const hashBuffer = await crypto.subtle.digest('SHA-1', data);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    const hashHex = hashArray.map(byte => byte.toString(16).padStart(2, '0')).join('');\n    return hashHex;\n}\n\nconst c = window.console;\n// Example usage:\nconst insertCursorMarker = (editor) => {\n    editor.selection.collapse();\n    editor.selection.setContent(COLCURPLACEHOLDER);\n    const contentWithMarker = editor.getContent();\n    removePlaceholderAtCursor(editor);\n    return contentWithMarker;\n  /*  const textNode = editor.selection.getNode();\n    const rng = editor.selection.getRng();\n    const placeholderIndex = textNode.textContent.indexOf(COLCURPLACEHOLDER);\n    console.log('currentStartContainer', placeholderIndex);\n    rng.setStart(textNode, placeholderIndex-1);\n    rng.setEnd(textNode, placeholderIndex);*/\n\n    //editor.selection.setRng(rng);\n    //rng.deleteContents();\n   //const markerElement = editor.getBody().querySelector(COLCURID);\n    //editor.dom.remove(markerElement); // Clean up marker\n   // return contentWithMarker;\n};\n\nconst restoreCursorPositionFromMarker = (editor, oldContentWithMarker) => {\n    const currentContentWithoutMarker = editor.getContent();\n    let changes = jsDiff.diffChars(oldContentWithMarker, currentContentWithoutMarker);\n    c.log('new patch for cursor', changes);\n    let currentContentWithMarker = '';\n    changes.forEach((part) => {\n        // green for additions, red for deletions\n        // grey for common parts\n        if (!part.removed || part.value === COLCURPLACEHOLDER) {\n            currentContentWithMarker += part.value;\n        }\n    });\n\n    editor.setContent(currentContentWithMarker);\n    removePlaceholderAtCursor(editor);\n    //const markerElement = editor.getBody().querySelector(COLCURID);\n    /*const placeholderIndex = currentContentWithMarker.indexOf(COLCURPLACEHOLDER);\n    if (!placeholderIndex) {\n        c.log('no marker found');\n        return;\n    }\n\n    const range = editor.dom.createRng();\n    const textNode = editor.getBody().firstChild;\n    range.setStart(textNode, placeholderIndex);\n    range.setEnd(textNode, placeholderIndex + 1);\n    editor.selection.setRng(range);\n    range.deleteContents();*/\n\n    /*range.setStartAfter(markerElement);\n    range.collapse(true);\n    editor.selection.setRng(range);\n    editor.dom.remove(markerElement); // Clean up marker*/\n\n};\n\nconst removePlaceholderAtCursor = (editor) => {\n    const body = editor.getBody();  // Get the body of the TinyMCE editor\n    const walker = document.createTreeWalker(body, NodeFilter.SHOW_TEXT, null, false);  // Traverse through text nodes\n\n    let found = false;\n    const currentFocusedElement = document.activeElement;\n    const isEditorFocused = (currentFocusedElement === editor.getBody());\n    while (walker.nextNode()) {\n        const textNode = walker.currentNode;\n        const textContent = textNode.textContent;\n        const placeholderIndex = textContent.indexOf(COLCURPLACEHOLDER);\n\n        // If the placeholder is found in this text node\n        if (placeholderIndex !== -1) {\n            found = true;\n\n            // Remove the placeholder character from the text node\n            const updatedText = textContent.slice(0, placeholderIndex) + textContent.slice(placeholderIndex + 1);\n            textNode.textContent = updatedText;\n\n            // Create a new range and set the cursor position to where the placeholder was\n            const range = editor.dom.createRng();\n            range.setStart(textNode, placeholderIndex);\n            range.collapse(true);  // Collapse the range to make it a cursor position\n            editor.selection.setRng(range);  // Set the new range as the selection\n\n           // editor.focus();  // Ensure the editor is focused after moving the cursor\n            break;  // Once found, exit the loop as it's a unique character\n        }\n    }\n\n    if (!found) {\n        console.log('Placeholder not found.');\n    }\n    if (currentFocusedElement && !isEditorFocused) {\n        currentFocusedElement.focus();\n    }\n}\n\n\nexport const register = (editor) => {\n    // Attempt to store the draft one final time before the page unloads.\n    // Note: This may need to be sent as a beacon instead.\n    // document.addEventListener('visibilitychange', visibilityChangedHandler);\n\n    // When the page is submitted as a form, remove the draft.\n    // editor.on('submit', removeAutoSaveSession);\n    // document.addEventListener(eventTypes.formSubmittedByJavascript, handleFormSubmittedByJavascript);\n    editor.on('init', () => {\n        let statusBarElement = document.createElement(\"p\");\n        const txt = document.createTextNode(\"Collaboratiny initialized.\");\n        statusBarElement.appendChild(txt);\n\n        editor\n            .getElement()\n            .nextElementSibling\n            .getElementsByClassName(\"tox-statusbar__right-container\")[0]\n            .prepend(statusBarElement);\n\n        setInterval(() => {\n            const newContent = editor.getContent();\n            sha1(newContent).then(hash => {\n                newHash = hash;\n                if (currentHash === '') {\n                    currentContent = newContent;\n                    currentHash = newHash;\n                    return;\n                }\n                if (newHash !== currentHash) {\n                    let patch = jsDiff.createPatch('a', currentContent, newContent);\n                    patch = patch.substring(HEADER.length);\n                    return fetchOne('tiny_collaborate_save_changes', {\n                        contextid: Options.getContextId(editor),\n                        elementid: editor.targetElm.id,\n                        oldcontenthash: currentHash,\n                        newcontenthash: newHash,\n                        changes: patch,\n                    })\n                    .then((result) => {\n                        currentContent = newContent;\n                        currentHash = newHash;\n                        return result;\n                    });\n                }\n            });\n            if (currentHash === '') {\n                return;\n            }\n\n            fetchOne('tiny_collaborate_set_position', {\n                contextid: Options.getContextId(editor),\n                elementid: editor.targetElm.id,\n                pageinstance: Options.getPageInstance(editor),\n                position: \"<empty>\",\n            }).then((result) => {\n                c.log(\"RESULT: \" + result);\n            }).fail((err) => {\n                c.error(err);\n            });\n\n            let newContent2 = editor.getContent();\n            const oldContentWithoutMarker = insertCursorMarker(editor);\n            let changesMade = false;\n            fetchOne('tiny_collaborate_get_changes', {\n                contextid: Options.getContextId(editor),\n              //  pagehash: Options.getPageHash(editor),\n             //   pageinstance: Options.getPageInstance(editor),\n                elementid: editor.targetElm.id,\n                currenthash: currentHash,\n            }).then((result) => {\n                if (result) {\n                    const changes = result.changes;\n                    for (const change of changes) {\n                        //  c.log('shorthcange', change);\n                        let patch = HEADER + change;\n                        //  c.log('changes', patch);\n                        //   c.log('parsedPatch', jsDiff.parsePatch(patch));\n                        newContent2 = jsDiff.applyPatch(newContent2, patch);\n                        changesMade = true;\n                    }\n                    if (changesMade) {\n                        if (newContent2 === false) {\n                            c.log('Patch FAILED');\n                        } else {\n                            //        c.log('newContent2', newContent2);\n                            editor.setContent(newContent2);\n                            currentContent = newContent2;\n                            sha1(newContent2).then(hash => {\n                                currentHash = hash;\n                                //             c.log('new hash', currentHash);\n                            });\n                            c.log('Applied patch successfully!');\n                        }\n                    }\n                    let s = result.positions.length === 1 ? '' : 's';\n                    statusBarElement.innerText = `${result.positions.length} collaborator${s}`;\n\n                    //clearInterval(intervalId);\n                }\n                if (changesMade) {\n                    restoreCursorPositionFromMarker(editor, oldContentWithoutMarker);\n                }\n            });\n\n        }, INTERVALTIMEOUT);\n\n        /*editor.on('Change', (event) => {\n            c.log('Change collaborative', event);\n        });*/\n        // Setup the Undo handler.\n        //editor.on('AddUndo', undoHandler);\n\n        /* if (editor.dom.isEmpty(editor.getBody())) {\n             Log.info(`Attempting to restore draft`, getLogSource(editor));\n             Storage.restoreDraft(editor);\n         } else {\n             // There was nothing to restore, so we can mark the editor as initialised.\n             Log.warn(`Skipping draft restoration. The editor is not empty.`, getLogSource(editor));\n             Options.markInitialised(editor);\n         }*/\n    });\n};\n"],"names":["currentContent","currentHash","newHash","HEADER","COLCURPLACEHOLDER","String","fromCharCode","fetchOne","methodname","args","sha1","message","data","TextEncoder","encode","hashBuffer","crypto","subtle","digest","Array","from","Uint8Array","map","byte","toString","padStart","join","c","window","console","removePlaceholderAtCursor","editor","body","getBody","walker","document","createTreeWalker","NodeFilter","SHOW_TEXT","found","currentFocusedElement","activeElement","isEditorFocused","nextNode","textNode","currentNode","textContent","placeholderIndex","indexOf","updatedText","slice","range","dom","createRng","setStart","collapse","selection","setRng","log","focus","on","statusBarElement","createElement","txt","createTextNode","appendChild","getElement","nextElementSibling","getElementsByClassName","prepend","setInterval","newContent","getContent","then","hash","patch","jsDiff","createPatch","substring","length","contextid","Options","getContextId","elementid","targetElm","id","oldcontenthash","newcontenthash","changes","result","pageinstance","getPageInstance","position","fail","err","error","newContent2","oldContentWithoutMarker","setContent","contentWithMarker","insertCursorMarker","changesMade","currenthash","change","applyPatch","s","positions","innerText","oldContentWithMarker","currentContentWithoutMarker","diffChars","currentContentWithMarker","forEach","part","removed","value","restoreCursorPositionFromMarker"],"mappings":"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"}