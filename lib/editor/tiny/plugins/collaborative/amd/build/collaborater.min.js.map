{"version":3,"file":"collaborater.min.js","sources":["../src/collaborater.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Storage helper for the Moodle Tiny Autosave plugin.\n *\n * @module      tiny_autosave/autosaver\n * @copyright   2022 Andrew Lyons <andrew@nicols.co.uk>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n//import * as Options from './options';\n//import * as Storage from './storage';mm\n//import Log from 'core/log';\n//import {eventTypes} from 'core_form/events';\n//import {getLogSource} from './common';\nimport * as jsDiff from './jsdiff/index';\nimport {call} from 'core/ajax';\nimport * as Options from \"./options\";\n\n\nlet currentContent = '';\nlet currentHash = '';\nlet newHash = '';\n//let newContent = '';\n//let lastHash = '';\nconst INTERVALTIMEOUT = 1000;\nconst HEADER = \"Index: a\\n===================================================================\\n\";\n\nconst fetchOne = (methodname, args) => call([{\n    methodname,\n    args,\n}])[0];\nlet intervalId = null;\n\nasync function sha1(message) {\n    const encoder = new TextEncoder();\n    const data = encoder.encode(message);\n    const hashBuffer = await crypto.subtle.digest('SHA-1', data);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    const hashHex = hashArray.map(byte => byte.toString(16).padStart(2, '0')).join('');\n    return hashHex;\n}\n\n// Example usage:\nconst insertCursorMarker = (editor) => {\n    const markerId = 'cursor-marker-' + new Date().getTime();\n    editor.selection.collapse();\n    editor.selection.setContent(`<span id=\"${markerId}\"></span>`);\n    return markerId;\n};\nconst restoreCursorPositionFromMarker = (editor, markerId) => {\n    const markerElement = editor.getBody().querySelector(`#${markerId}`);\n    if (markerElement) {\n        const range = editor.dom.createRng();\n        range.setStartAfter(markerElement);\n        range.collapse(true);\n        editor.selection.setRng(range);\n        editor.dom.remove(markerElement); // Clean up marker\n       // editor.focus();\n    } else {\n        // Fallback if marker not found\n       // editor.focus();\n        editor.selection.select(editor.getBody(), true);\n        editor.selection.collapse(false);\n    }\n};\n\n\nexport const register = (editor) => {\n        // Attempt to store the draft one final time before the page unloads.\n    // Note: This may need to be sent as a beacon instead.\n   // document.addEventListener('visibilitychange', visibilityChangedHandler);\n\n    // When the page is submitted as a form, remove the draft.\n   // editor.on('submit', removeAutoSaveSession);\n   // document.addEventListener(eventTypes.formSubmittedByJavascript, handleFormSubmittedByJavascript);\n    const c = window.console;\n    editor.on('init', () => {\n        setInterval(() => {\n            const newContent = editor.getContent();\n            sha1(newContent).then(hash => {\n                newHash = hash;\n                if (currentHash === '') {\n                    currentContent = newContent;\n                    currentHash = newHash;\n                    return;\n                }\n                if (newHash !== currentHash) {\n                    let patch = jsDiff.createPatch('a', currentContent, newContent);\n                    patch = patch.substring(HEADER.length);\n                   /* c.log('contextid', Options.getContextId(editor));\n                    c.log('pagehash', Options.getPageHash(editor));\n                    c.log('pageinstance', Options.getPageInstance(editor));\n                    c.log('elementid', editor.targetElm.id);\n                    c.log('oldcontenthash', currentHash);\n                    c.log('newcontenthash', newHash);\n                    c.log('changes', patch);*/\n                    return fetchOne('tiny_collaborate_save_changes', {\n                        contextid: Options.getContextId(editor),\n                        pagehash: Options.getPageHash(editor),\n                        //pageinstance: Options.getPageInstance(editor),\n                        elementid: editor.targetElm.id,\n                        /*drftid: Options.getDraftItemId(editor),*/\n                        oldcontenthash: currentHash,\n                        newcontenthash: newHash,\n                        changes: patch,\n\n                    })\n                    .then((result) => {\n                       //* pendingPromise.resolve();\n                       // c.log('new hash', newHash);\n                      //  c.log('diff', patch);\n                        currentContent = newContent;\n                        currentHash = newHash;\n                        return result;\n                    });\n                }\n            });\n            if (currentHash === '') {\n                return;\n            }\n         //   const markerId = insertCursorMarker(editor);\n            let newContent2 = editor.getContent();\n            fetchOne('tiny_collaborate_get_changes', {\n                contextid: Options.getContextId(editor),\n                pagehash: Options.getPageHash(editor),\n             //   pageinstance: Options.getPageInstance(editor),\n                elementid: editor.targetElm.id,\n                currenthash: currentHash,\n            }).then((result) => {\n                if (result) {\n                    let changesMade = false;\n                    for (let i in result) {\n                        let change = result[i];\n                        c.log('shorthcange', change);\n                        let patch = HEADER + change;\n                        c.log('changes', patch);\n                        c.log('parsedPatch', jsDiff.parsePatch(patch));\n                        newContent2 = jsDiff.applyPatch(newContent2, patch);\n                        changesMade = true;\n                    }\n                    if (changesMade) {\n                        if (newContent2 === false) {\n                            c.log('Patch FAILED');\n                        } else {\n                            c.log('newContent2', newContent2);\n                            editor.setContent(newContent2);\n                            currentContent = newContent2;\n                            sha1(newContent2).then(hash => {\n                                currentHash = hash;\n                                c.log('new hash', currentHash);\n                            });\n                        }\n                    }\n                    //clearInterval(intervalId);\n                }\n\n             //   restoreCursorPositionFromMarker(editor, markerId);\n            });\n\n        }, INTERVALTIMEOUT);\n\n        /*editor.on('Change', (event) => {\n            c.log('Change collaborative', event);\n        });*/\n        // Setup the Undo handler.\n        //editor.on('AddUndo', undoHandler);\n\n       /* if (editor.dom.isEmpty(editor.getBody())) {\n            Log.info(`Attempting to restore draft`, getLogSource(editor));\n            Storage.restoreDraft(editor);\n        } else {\n            // There was nothing to restore, so we can mark the editor as initialised.\n            Log.warn(`Skipping draft restoration. The editor is not empty.`, getLogSource(editor));\n            Options.markInitialised(editor);\n        }*/\n    });\n};\n"],"names":["_getRequireWildcardCache","e","WeakMap","r","t","_interopRequireWildcard","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","jsDiff","Options","currentContent","currentHash","newHash","HEADER","fetchOne","methodname","args","async","sha1","message","data","TextEncoder","encode","hashBuffer","crypto","subtle","digest","Array","from","Uint8Array","map","byte","toString","padStart","join","_exports","register","editor","c","window","console","on","setInterval","newContent","getContent","then","hash","patch","createPatch","substring","contextid","getContextId","pagehash","getPageHash","elementid","targetElm","id","oldcontenthash","newcontenthash","changes","result","newContent2","currenthash","changesMade","change","log","parsePatch","applyPatch","setContent"],"mappings":"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"}