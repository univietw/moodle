{"version":3,"file":"collaborater.min.js","sources":["../src/collaborater.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Storage helper for the Moodle Tiny Autosave plugin.\n *\n * @module      tiny_autosave/autosaver\n * @copyright   2022 Andrew Lyons <andrew@nicols.co.uk>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n//import * as Options from './options';\n//import * as Storage from './storage';mm\n//import Log from 'core/log';\n//import {eventTypes} from 'core_form/events';\n//import {getLogSource} from './common';\nimport * as jsDiff from './jsdiff/index';\nimport {call} from 'core/ajax';\nimport * as Options from \"./options\";\n\n\nlet currentContent = '';\nlet currentHash = '';\nlet newHash = '';\n//let newContent = '';\n//let lastHash = '';\nconst INTERVALTIMEOUT = 1000;\nconst HEADER = \"Index: a\\n===================================================================\\n\";\nconst COLCURSPAN = '<span id=\"COLCUR\"></span>';\nconst COLCURID = '#COLCUR';\nconst COLCURPLACEHOLDER = String.fromCharCode(254);\n\nconst fetchOne = (methodname, args) => call([{\n    methodname,\n    args,\n}])[0];\nlet intervalId = null;\n\nasync function sha1(message) {\n    const encoder = new TextEncoder();\n    const data = encoder.encode(message);\n    const hashBuffer = await crypto.subtle.digest('SHA-1', data);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    const hashHex = hashArray.map(byte => byte.toString(16).padStart(2, '0')).join('');\n    return hashHex;\n}\n\nconst c = window.console;\n// Example usage:\nconst insertCursorMarker = (editor) => {\n    editor.selection.collapse();\n    editor.selection.setContent(COLCURPLACEHOLDER);\n    const contentWithMarker = editor.getContent();\n    removePlaceholderAtCursor(editor);\n    return contentWithMarker;\n  /*  const textNode = editor.selection.getNode();\n    const rng = editor.selection.getRng();\n    const placeholderIndex = textNode.textContent.indexOf(COLCURPLACEHOLDER);\n    console.log('currentStartContainer', placeholderIndex);\n    rng.setStart(textNode, placeholderIndex-1);\n    rng.setEnd(textNode, placeholderIndex);*/\n\n    //editor.selection.setRng(rng);\n    //rng.deleteContents();\n   //const markerElement = editor.getBody().querySelector(COLCURID);\n    //editor.dom.remove(markerElement); // Clean up marker\n   // return contentWithMarker;\n};\n\nconst restoreCursorPositionFromMarker = (editor, oldContentWithMarker) => {\n    const currentContentWithoutMarker = editor.getContent();\n    let changes = jsDiff.diffChars(oldContentWithMarker, currentContentWithoutMarker);\n    c.log('new patch for cursor', changes);\n    let currentContentWithMarker = '';\n    changes.forEach((part) => {\n        // green for additions, red for deletions\n        // grey for common parts\n        if (!part.removed || part.value === COLCURPLACEHOLDER) {\n            currentContentWithMarker += part.value;\n        }\n    });\n\n    editor.setContent(currentContentWithMarker);\n    removePlaceholderAtCursor(editor);\n    //const markerElement = editor.getBody().querySelector(COLCURID);\n    /*const placeholderIndex = currentContentWithMarker.indexOf(COLCURPLACEHOLDER);\n    if (!placeholderIndex) {\n        c.log('no marker found');\n        return;\n    }\n\n    const range = editor.dom.createRng();\n    const textNode = editor.getBody().firstChild;\n    range.setStart(textNode, placeholderIndex);\n    range.setEnd(textNode, placeholderIndex + 1);\n    editor.selection.setRng(range);\n    range.deleteContents();*/\n\n    /*range.setStartAfter(markerElement);\n    range.collapse(true);\n    editor.selection.setRng(range);\n    editor.dom.remove(markerElement); // Clean up marker*/\n\n};\n\nconst removePlaceholderAtCursor = (editor) => {\n    const body = editor.getBody();  // Get the body of the TinyMCE editor\n    const walker = document.createTreeWalker(body, NodeFilter.SHOW_TEXT, null, false);  // Traverse through text nodes\n\n    let found = false;\n\n    while (walker.nextNode()) {\n        const textNode = walker.currentNode;\n        const textContent = textNode.textContent;\n        const placeholderIndex = textContent.indexOf(COLCURPLACEHOLDER);\n\n        // If the placeholder is found in this text node\n        if (placeholderIndex !== -1) {\n            found = true;\n\n            // Remove the placeholder character from the text node\n            const updatedText = textContent.slice(0, placeholderIndex) + textContent.slice(placeholderIndex + 1);\n            textNode.textContent = updatedText;\n\n            // Create a new range and set the cursor position to where the placeholder was\n            const range = editor.dom.createRng();\n            range.setStart(textNode, placeholderIndex);\n            range.collapse(true);  // Collapse the range to make it a cursor position\n            editor.selection.setRng(range);  // Set the new range as the selection\n\n            editor.focus();  // Ensure the editor is focused after moving the cursor\n            break;  // Once found, exit the loop as it's a unique character\n        }\n    }\n\n    if (!found) {\n        console.log('Placeholder not found.');\n    }\n}\n\nconst removePlaceholderAtCursor2 = (editor) => {\n    const selection = editor.selection;\n    const range = selection.getRng();  // Get the current range (cursor position)\n    let newRange = null;\n    // Check if we're in a text node and if it contains the placeholder character\n    if (range.startContainer.nodeType === 3) {  // 3 means it's a text node\n        const textNode = range.startContainer;\n        const text = textNode.textContent;\n        const placeholderIndex = text.indexOf(COLCURPLACEHOLDER);\n\n        if (placeholderIndex !== -1) {\n            // Create a new range to delete just the placeholder character\n            newRange = editor.dom.createRng();\n            newRange.setStart(textNode, placeholderIndex);\n            newRange.setEnd(textNode, placeholderIndex + 1);  // Select the placeholder character\n\n            // Delete the placeholder character\n            newRange.deleteContents();\n        }\n    } else if (range.startContainer.nodeType === 1) {\n        const element = range.startContainer;\n\n        // Iterate over child nodes to find and remove the placeholder in text nodes\n        for (let i = 0; i < element.childNodes.length; i++) {\n            const child = element.childNodes[i];\n\n            if (child.nodeType === 3) {  // If it's a text node\n                const text = child.textContent;\n                const placeholderIndex = text.indexOf(COLCURPLACEHOLDER);\n\n                if (placeholderIndex !== -1) {\n                    // Create a new range to delete the placeholder character\n                    newRange = editor.dom.createRng();\n                    newRange.setStart(child, placeholderIndex);\n                    newRange.setEnd(child, placeholderIndex + 1);  // Select the placeholder character\n\n                    // Delete the placeholder character\n                    newRange.deleteContents();\n                    break;  // Once found and deleted, we can stop\n                }\n            }\n        }\n    }\n    if (newRange !== null) {\n        editor.selection.setRng(newRange);  // Set the new range to update the cursor position\n    }\n}\n\n\nexport const register = (editor) => {\n    // Attempt to store the draft one final time before the page unloads.\n    // Note: This may need to be sent as a beacon instead.\n    // document.addEventListener('visibilitychange', visibilityChangedHandler);\n\n    // When the page is submitted as a form, remove the draft.\n    // editor.on('submit', removeAutoSaveSession);\n    // document.addEventListener(eventTypes.formSubmittedByJavascript, handleFormSubmittedByJavascript);\n    editor.on('init', () => {\n        setInterval(() => {\n            const newContent = editor.getContent();\n            sha1(newContent).then(hash => {\n                newHash = hash;\n                if (currentHash === '') {\n                    currentContent = newContent;\n                    currentHash = newHash;\n                    return;\n                }\n                if (newHash !== currentHash) {\n                    let patch = jsDiff.createPatch('a', currentContent, newContent);\n                    patch = patch.substring(HEADER.length);\n                    /* c.log('contextid', Options.getContextId(editor));\n                     c.log('pagehash', Options.getPageHash(editor));\n                     c.log('pageinstance', Options.getPageInstance(editor));\n                     c.log('elementid', editor.targetElm.id);\n                     c.log('oldcontenthash', currentHash);\n                     c.log('newcontenthash', newHash);\n                     c.log('changes', patch);*/\n                    return fetchOne('tiny_collaborate_save_changes', {\n                        contextid: Options.getContextId(editor),\n                        pagehash: Options.getPageHash(editor),\n                        //pageinstance: Options.getPageInstance(editor),\n                        elementid: editor.targetElm.id,\n                        /*drftid: Options.getDraftItemId(editor),*/\n                        oldcontenthash: currentHash,\n                        newcontenthash: newHash,\n                        changes: patch,\n\n                    })\n                        .then((result) => {\n                            //* pendingPromise.resolve();\n                            // c.log('new hash', newHash);\n                            //  c.log('diff', patch);\n                            currentContent = newContent;\n                            currentHash = newHash;\n                            return result;\n                        });\n                }\n            });\n            if (currentHash === '') {\n                return;\n            }\n            let newContent2 = editor.getContent();\n            const oldContentWithoutMarker = insertCursorMarker(editor);\n            let changesMade = false;\n            fetchOne('tiny_collaborate_get_changes', {\n                contextid: Options.getContextId(editor),\n                pagehash: Options.getPageHash(editor),\n                //   pageinstance: Options.getPageInstance(editor),\n                elementid: editor.targetElm.id,\n                currenthash: currentHash,\n            }).then((result) => {\n                if (result) {\n                    for (let i in result) {\n                        let change = result[i];\n                        //  c.log('shorthcange', change);\n                        let patch = HEADER + change;\n                        //  c.log('changes', patch);\n                        //   c.log('parsedPatch', jsDiff.parsePatch(patch));\n                        newContent2 = jsDiff.applyPatch(newContent2, patch);\n                        changesMade = true;\n                    }\n                    if (changesMade) {\n                        if (newContent2 === false) {\n                            c.log('Patch FAILED');\n                        } else {\n                            //        c.log('newContent2', newContent2);\n                            editor.setContent(newContent2);\n                            currentContent = newContent2;\n                            sha1(newContent2).then(hash => {\n                                currentHash = hash;\n                                //             c.log('new hash', currentHash);\n                            });\n                            c.log('Applied patch successfully!');\n                        }\n                    }\n                    //clearInterval(intervalId);\n                }\n                if (changesMade) {\n                    restoreCursorPositionFromMarker(editor, oldContentWithoutMarker);\n                }\n            });\n\n        }, INTERVALTIMEOUT);\n\n        /*editor.on('Change', (event) => {\n            c.log('Change collaborative', event);\n        });*/\n        // Setup the Undo handler.\n        //editor.on('AddUndo', undoHandler);\n\n        /* if (editor.dom.isEmpty(editor.getBody())) {\n             Log.info(`Attempting to restore draft`, getLogSource(editor));\n             Storage.restoreDraft(editor);\n         } else {\n             // There was nothing to restore, so we can mark the editor as initialised.\n             Log.warn(`Skipping draft restoration. The editor is not empty.`, getLogSource(editor));\n             Options.markInitialised(editor);\n         }*/\n    });\n};\n"],"names":["_getRequireWildcardCache","e","WeakMap","r","t","_interopRequireWildcard","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","jsDiff","Options","currentContent","currentHash","newHash","HEADER","COLCURPLACEHOLDER","String","fromCharCode","fetchOne","methodname","args","async","sha1","message","data","TextEncoder","encode","hashBuffer","crypto","subtle","digest","Array","from","Uint8Array","map","byte","toString","padStart","join","c","window","console","removePlaceholderAtCursor","editor","body","getBody","walker","document","createTreeWalker","NodeFilter","SHOW_TEXT","found","nextNode","textNode","currentNode","textContent","placeholderIndex","indexOf","updatedText","slice","range","dom","createRng","setStart","collapse","selection","setRng","focus","log","_exports","register","on","setInterval","newContent","getContent","then","hash","patch","createPatch","substring","contextid","getContextId","pagehash","getPageHash","elementid","targetElm","id","oldcontenthash","newcontenthash","changes","result","newContent2","oldContentWithoutMarker","setContent","contentWithMarker","insertCursorMarker","changesMade","currenthash","change","applyPatch","restoreCursorPositionFromMarker","oldContentWithMarker","currentContentWithoutMarker","diffChars","currentContentWithMarker","forEach","part","removed","value"],"mappings":"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"}