{"version":3,"file":"collaborater.min.js","sources":["../src/collaborater.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Storage helper for the Moodle Tiny Autosave plugin.\n *\n * @module      tiny_autosave/autosaver\n * @copyright   2022 Andrew Lyons <andrew@nicols.co.uk>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n//import * as Options from './options';\n//import * as Storage from './storage';mm\n//import Log from 'core/log';\n//import {eventTypes} from 'core_form/events';\n//import {getLogSource} from './common';\nimport * as jsDiff from './jsdiff/index';\nimport {call} from 'core/ajax';\nimport * as Options from \"./options\";\n\n\nlet currentContent = '';\nlet currentHash = '';\nlet newHash = '';\n//let newContent = '';\n//let lastHash = '';\nconst INTERVALTIMEOUT = 1000;\nconst HEADER = \"Index: a\\n===================================================================\\n\";\nconst COLCURSPAN = '<span id=\"COLCUR\"></span>';\nconst COLCURID = '#COLCUR';\nconst COLCURPLACEHOLDER = String.fromCharCode(254);\n\nconst fetchOne = (methodname, args) => call([{\n    methodname,\n    args,\n}])[0];\nlet intervalId = null;\n\nasync function sha1(message) {\n    const encoder = new TextEncoder();\n    const data = encoder.encode(message);\n    const hashBuffer = await crypto.subtle.digest('SHA-1', data);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    const hashHex = hashArray.map(byte => byte.toString(16).padStart(2, '0')).join('');\n    return hashHex;\n}\n\nconst c = window.console;\n// Example usage:\nconst insertCursorMarker = (editor) => {\n    editor.selection.collapse();\n    editor.selection.setContent(COLCURPLACEHOLDER);\n    const contentWithMarker = editor.getContent();\n    removePlaceholderAtCursor(editor);\n    return contentWithMarker;\n  /*  const textNode = editor.selection.getNode();\n    const rng = editor.selection.getRng();\n    const placeholderIndex = textNode.textContent.indexOf(COLCURPLACEHOLDER);\n    console.log('currentStartContainer', placeholderIndex);\n    rng.setStart(textNode, placeholderIndex-1);\n    rng.setEnd(textNode, placeholderIndex);*/\n\n    //editor.selection.setRng(rng);\n    //rng.deleteContents();\n   //const markerElement = editor.getBody().querySelector(COLCURID);\n    //editor.dom.remove(markerElement); // Clean up marker\n   // return contentWithMarker;\n};\n\nconst restoreCursorPositionFromMarker = (editor, oldContentWithMarker) => {\n    const currentContentWithoutMarker = editor.getContent();\n    let changes = jsDiff.diffChars(oldContentWithMarker, currentContentWithoutMarker);\n    c.log('new patch for cursor', changes);\n    let currentContentWithMarker = '';\n    changes.forEach((part) => {\n        // green for additions, red for deletions\n        // grey for common parts\n        if (!part.removed || part.value === COLCURPLACEHOLDER) {\n            currentContentWithMarker += part.value;\n        }\n    });\n\n    editor.setContent(currentContentWithMarker);\n    removePlaceholderAtCursor(editor);\n    //const markerElement = editor.getBody().querySelector(COLCURID);\n    /*const placeholderIndex = currentContentWithMarker.indexOf(COLCURPLACEHOLDER);\n    if (!placeholderIndex) {\n        c.log('no marker found');\n        return;\n    }\n\n    const range = editor.dom.createRng();\n    const textNode = editor.getBody().firstChild;\n    range.setStart(textNode, placeholderIndex);\n    range.setEnd(textNode, placeholderIndex + 1);\n    editor.selection.setRng(range);\n    range.deleteContents();*/\n\n    /*range.setStartAfter(markerElement);\n    range.collapse(true);\n    editor.selection.setRng(range);\n    editor.dom.remove(markerElement); // Clean up marker*/\n\n};\n\nconst removePlaceholderAtCursor = (editor) => {\n    const body = editor.getBody();  // Get the body of the TinyMCE editor\n    const walker = document.createTreeWalker(body, NodeFilter.SHOW_TEXT, null, false);  // Traverse through text nodes\n\n    let found = false;\n    const currentFocusedElement = document.activeElement;\n    const isEditorFocused = (currentFocusedElement === editor.getBody());\n    while (walker.nextNode()) {\n        const textNode = walker.currentNode;\n        const textContent = textNode.textContent;\n        const placeholderIndex = textContent.indexOf(COLCURPLACEHOLDER);\n\n        // If the placeholder is found in this text node\n        if (placeholderIndex !== -1) {\n            found = true;\n\n            // Remove the placeholder character from the text node\n            const updatedText = textContent.slice(0, placeholderIndex) + textContent.slice(placeholderIndex + 1);\n            textNode.textContent = updatedText;\n\n            // Create a new range and set the cursor position to where the placeholder was\n            const range = editor.dom.createRng();\n            range.setStart(textNode, placeholderIndex);\n            range.collapse(true);  // Collapse the range to make it a cursor position\n            editor.selection.setRng(range);  // Set the new range as the selection\n\n           // editor.focus();  // Ensure the editor is focused after moving the cursor\n            break;  // Once found, exit the loop as it's a unique character\n        }\n    }\n\n    if (!found) {\n        console.log('Placeholder not found.');\n    }\n    if (currentFocusedElement && !isEditorFocused) {\n        currentFocusedElement.focus();\n    }\n}\n\n\nexport const register = (editor) => {\n    // Attempt to store the draft one final time before the page unloads.\n    // Note: This may need to be sent as a beacon instead.\n    // document.addEventListener('visibilitychange', visibilityChangedHandler);\n\n    // When the page is submitted as a form, remove the draft.\n    // editor.on('submit', removeAutoSaveSession);\n    // document.addEventListener(eventTypes.formSubmittedByJavascript, handleFormSubmittedByJavascript);\n    editor.on('init', () => {\n        let status_bar_element = document.createElement(\"p\");\n        const txt = document.createTextNode(\"Collaboratiny initialized.\");\n        status_bar_element.appendChild(txt);\n\n        editor\n            .getElement()\n            .nextElementSibling\n            .getElementsByClassName(\"tox-statusbar__right-container\")[0]\n            .prepend(status_bar_element);\n\n        setInterval(() => {\n            const newContent = editor.getContent();\n            sha1(newContent).then(hash => {\n                newHash = hash;\n                if (currentHash === '') {\n                    currentContent = newContent;\n                    currentHash = newHash;\n                    return;\n                }\n                if (newHash !== currentHash) {\n                    let patch = jsDiff.createPatch('a', currentContent, newContent);\n                    patch = patch.substring(HEADER.length);\n                    return fetchOne('tiny_collaborate_save_changes', {\n                        contextid: Options.getContextId(editor),\n                        elementid: editor.targetElm.id,\n                        oldcontenthash: currentHash,\n                        newcontenthash: newHash,\n                        changes: patch,\n\n                    })\n                    .then((result) => {\n                        currentContent = newContent;\n                        currentHash = newHash;\n                        return result;\n                    });\n                }\n            });\n            if (currentHash === '') {\n                return;\n            }\n            let newContent2 = editor.getContent();\n            const oldContentWithoutMarker = insertCursorMarker(editor);\n            let changesMade = false;\n            fetchOne('tiny_collaborate_get_changes', {\n                contextid: Options.getContextId(editor),\n              //  pagehash: Options.getPageHash(editor),\n             //   pageinstance: Options.getPageInstance(editor),\n                elementid: editor.targetElm.id,\n                currenthash: currentHash,\n            }).then((result) => {\n                if (result) {\n                    const changes = result.changes;\n                    for (const change of changes) {\n                        //  c.log('shorthcange', change);\n                        let patch = HEADER + change;\n                        //  c.log('changes', patch);\n                        //   c.log('parsedPatch', jsDiff.parsePatch(patch));\n                        newContent2 = jsDiff.applyPatch(newContent2, patch);\n                        changesMade = true;\n                    }\n                    if (changesMade) {\n                        if (newContent2 === false) {\n                            c.log('Patch FAILED');\n                        } else {\n                            //        c.log('newContent2', newContent2);\n                            editor.setContent(newContent2);\n                            currentContent = newContent2;\n                            sha1(newContent2).then(hash => {\n                                currentHash = hash;\n                                //             c.log('new hash', currentHash);\n                            });\n                            c.log('Applied patch successfully!');\n                        }\n                    }\n                    status_bar_element.innerText = \"Collaborators: \" + result.positions.length;\n\n                    //clearInterval(intervalId);\n                }\n                if (changesMade) {\n                    restoreCursorPositionFromMarker(editor, oldContentWithoutMarker);\n                }\n            });\n\n        }, INTERVALTIMEOUT);\n\n        /*editor.on('Change', (event) => {\n            c.log('Change collaborative', event);\n        });*/\n        // Setup the Undo handler.\n        //editor.on('AddUndo', undoHandler);\n\n        /* if (editor.dom.isEmpty(editor.getBody())) {\n             Log.info(`Attempting to restore draft`, getLogSource(editor));\n             Storage.restoreDraft(editor);\n         } else {\n             // There was nothing to restore, so we can mark the editor as initialised.\n             Log.warn(`Skipping draft restoration. The editor is not empty.`, getLogSource(editor));\n             Options.markInitialised(editor);\n         }*/\n    });\n};\n"],"names":["_getRequireWildcardCache","e","WeakMap","r","t","_interopRequireWildcard","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","jsDiff","Options","currentContent","currentHash","newHash","HEADER","COLCURPLACEHOLDER","String","fromCharCode","fetchOne","methodname","args","async","sha1","message","data","TextEncoder","encode","hashBuffer","crypto","subtle","digest","Array","from","Uint8Array","map","byte","toString","padStart","join","c","window","console","removePlaceholderAtCursor","editor","body","getBody","walker","document","createTreeWalker","NodeFilter","SHOW_TEXT","found","currentFocusedElement","activeElement","isEditorFocused","nextNode","textNode","currentNode","textContent","placeholderIndex","indexOf","updatedText","slice","range","dom","createRng","setStart","collapse","selection","setRng","log","focus","_exports","register","on","status_bar_element","createElement","txt","createTextNode","appendChild","getElement","nextElementSibling","getElementsByClassName","prepend","setInterval","newContent","getContent","then","hash","patch","createPatch","substring","contextid","getContextId","elementid","targetElm","id","oldcontenthash","newcontenthash","changes","result","newContent2","oldContentWithoutMarker","setContent","contentWithMarker","insertCursorMarker","changesMade","currenthash","change","applyPatch","innerText","positions","length","restoreCursorPositionFromMarker","oldContentWithMarker","currentContentWithoutMarker","diffChars","currentContentWithMarker","forEach","part","removed","value"],"mappings":"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"}