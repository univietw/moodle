define("tiny_collaborative/jsdiff/diff/base",["exports"],(function(_exports){function Diff(){}function buildValues(diff,lastComponent,newString,oldString,useLongestToken){const components=[];let nextComponent;for(;lastComponent;)components.push(lastComponent),nextComponent=lastComponent.previousComponent,delete lastComponent.previousComponent,lastComponent=nextComponent;components.reverse();let componentPos=0,componentLen=components.length,newPos=0,oldPos=0;for(;componentPos<componentLen;componentPos++){let component=components[componentPos];if(component.removed)component.value=diff.join(oldString.slice(oldPos,oldPos+component.count)),oldPos+=component.count;else{if(!component.added&&useLongestToken){let value=newString.slice(newPos,newPos+component.count);value=value.map((function(value,i){let oldValue=oldString[oldPos+i];return oldValue.length>value.length?oldValue:value})),component.value=diff.join(value)}else component.value=diff.join(newString.slice(newPos,newPos+component.count));newPos+=component.count,component.added||(oldPos+=component.count)}}return components}return Object.defineProperty(_exports,"__esModule",{value:!0}),_exports.default=Diff,Diff.prototype={diff(oldString,newString){let options=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},callback=options.callback;"function"==typeof options&&(callback=options,options={});let self=this;function done(value){return value=self.postProcess(value,options),callback?(setTimeout((function(){callback(value)}),0),!0):value}oldString=this.castInput(oldString,options),newString=this.castInput(newString,options),oldString=this.removeEmpty(this.tokenize(oldString,options));let newLen=(newString=this.removeEmpty(this.tokenize(newString,options))).length,oldLen=oldString.length,editLength=1,maxEditLength=newLen+oldLen;null!=options.maxEditLength&&(maxEditLength=Math.min(maxEditLength,options.maxEditLength));const maxExecutionTime=options.timeout??1/0,abortAfterTimestamp=Date.now()+maxExecutionTime;let bestPath=[{oldPos:-1,lastComponent:void 0}],newPos=this.extractCommon(bestPath[0],newString,oldString,0,options);if(bestPath[0].oldPos+1>=oldLen&&newPos+1>=newLen)return done(buildValues(self,bestPath[0].lastComponent,newString,oldString,self.useLongestToken));let minDiagonalToConsider=-1/0,maxDiagonalToConsider=1/0;function execEditLength(){for(let diagonalPath=Math.max(minDiagonalToConsider,-editLength);diagonalPath<=Math.min(maxDiagonalToConsider,editLength);diagonalPath+=2){let basePath,removePath=bestPath[diagonalPath-1],addPath=bestPath[diagonalPath+1];removePath&&(bestPath[diagonalPath-1]=void 0);let canAdd=!1;if(addPath){const addPathNewPos=addPath.oldPos-diagonalPath;canAdd=addPath&&0<=addPathNewPos&&addPathNewPos<newLen}let canRemove=removePath&&removePath.oldPos+1<oldLen;if(canAdd||canRemove){if(basePath=!canRemove||canAdd&&removePath.oldPos<addPath.oldPos?self.addToPath(addPath,!0,!1,0,options):self.addToPath(removePath,!1,!0,1,options),newPos=self.extractCommon(basePath,newString,oldString,diagonalPath,options),basePath.oldPos+1>=oldLen&&newPos+1>=newLen)return done(buildValues(self,basePath.lastComponent,newString,oldString,self.useLongestToken));bestPath[diagonalPath]=basePath,basePath.oldPos+1>=oldLen&&(maxDiagonalToConsider=Math.min(maxDiagonalToConsider,diagonalPath-1)),newPos+1>=newLen&&(minDiagonalToConsider=Math.max(minDiagonalToConsider,diagonalPath+1))}else bestPath[diagonalPath]=void 0}editLength++}if(callback)!function exec(){setTimeout((function(){if(editLength>maxEditLength||Date.now()>abortAfterTimestamp)return callback();execEditLength()||exec()}),0)}();else for(;editLength<=maxEditLength&&Date.now()<=abortAfterTimestamp;){let ret=execEditLength();if(ret)return ret}},addToPath(path,added,removed,oldPosInc,options){let last=path.lastComponent;return last&&!options.oneChangePerToken&&last.added===added&&last.removed===removed?{oldPos:path.oldPos+oldPosInc,lastComponent:{count:last.count+1,added:added,removed:removed,previousComponent:last.previousComponent}}:{oldPos:path.oldPos+oldPosInc,lastComponent:{count:1,added:added,removed:removed,previousComponent:last}}},extractCommon(basePath,newString,oldString,diagonalPath,options){let newLen=newString.length,oldLen=oldString.length,oldPos=basePath.oldPos,newPos=oldPos-diagonalPath,commonCount=0;for(;newPos+1<newLen&&oldPos+1<oldLen&&this.equals(oldString[oldPos+1],newString[newPos+1],options);)newPos++,oldPos++,commonCount++,options.oneChangePerToken&&(basePath.lastComponent={count:1,previousComponent:basePath.lastComponent,added:!1,removed:!1});return commonCount&&!options.oneChangePerToken&&(basePath.lastComponent={count:commonCount,previousComponent:basePath.lastComponent,added:!1,removed:!1}),basePath.oldPos=oldPos,newPos},equals:(left,right,options)=>options.comparator?options.comparator(left,right):left===right||options.ignoreCase&&left.toLowerCase()===right.toLowerCase(),removeEmpty(array){let ret=[];for(let i=0;i<array.length;i++)array[i]&&ret.push(array[i]);return ret},castInput:value=>value,tokenize:value=>Array.from(value),join:chars=>chars.join(""),postProcess:changeObjects=>changeObjects},_exports.default}));

//# sourceMappingURL=base.min.js.map