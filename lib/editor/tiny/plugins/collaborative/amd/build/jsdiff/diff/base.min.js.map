{"version":3,"file":"base.min.js","sources":["../../../src/jsdiff/diff/base.js"],"sourcesContent":["export default function Diff() {}\n\nDiff.prototype = {\n  diff(oldString, newString, options = {}) {\n    let callback = options.callback;\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    let self = this;\n\n    function done(value) {\n      value = self.postProcess(value, options);\n      if (callback) {\n        setTimeout(function() { callback(value); }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    }\n\n    // Allow subclasses to massage the input prior to running\n    oldString = this.castInput(oldString, options);\n    newString = this.castInput(newString, options);\n\n    oldString = this.removeEmpty(this.tokenize(oldString, options));\n    newString = this.removeEmpty(this.tokenize(newString, options));\n\n    let newLen = newString.length, oldLen = oldString.length;\n    let editLength = 1;\n    let maxEditLength = newLen + oldLen;\n    if(options.maxEditLength != null) {\n      maxEditLength = Math.min(maxEditLength, options.maxEditLength);\n    }\n    const maxExecutionTime = options.timeout ?? Infinity;\n    const abortAfterTimestamp = Date.now() + maxExecutionTime;\n\n    let bestPath = [{ oldPos: -1, lastComponent: undefined }];\n\n    // Seed editLength = 0, i.e. the content starts with the same values\n    let newPos = this.extractCommon(bestPath[0], newString, oldString, 0, options);\n    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n      // Identity per the equality and tokenizer\n      return done(buildValues(self, bestPath[0].lastComponent, newString, oldString, self.useLongestToken));\n    }\n\n    // Once we hit the right edge of the edit graph on some diagonal k, we can\n    // definitely reach the end of the edit graph in no more than k edits, so\n    // there's no point in considering any moves to diagonal k+1 any more (from\n    // which we're guaranteed to need at least k+1 more edits).\n    // Similarly, once we've reached the bottom of the edit graph, there's no\n    // point considering moves to lower diagonals.\n    // We record this fact by setting minDiagonalToConsider and\n    // maxDiagonalToConsider to some finite value once we've hit the edge of\n    // the edit graph.\n    // This optimization is not faithful to the original algorithm presented in\n    // Myers's paper, which instead pointlessly extends D-paths off the end of\n    // the edit graph - see page 7 of Myers's paper which notes this point\n    // explicitly and illustrates it with a diagram. This has major performance\n    // implications for some common scenarios. For instance, to compute a diff\n    // where the new text simply appends d characters on the end of the\n    // original text of length n, the true Myers algorithm will take O(n+d^2)\n    // time while this optimization needs only O(n+d) time.\n    let minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;\n\n    // Main worker method. checks all permutations of a given edit length for acceptance.\n    function execEditLength() {\n      for (\n        let diagonalPath = Math.max(minDiagonalToConsider, -editLength);\n        diagonalPath <= Math.min(maxDiagonalToConsider, editLength);\n        diagonalPath += 2\n      ) {\n        let basePath;\n        let removePath = bestPath[diagonalPath - 1],\n            addPath = bestPath[diagonalPath + 1];\n        if (removePath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        let canAdd = false;\n        if (addPath) {\n          // what newPos will be after we do an insertion:\n          const addPathNewPos = addPath.oldPos - diagonalPath;\n          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;\n        }\n\n        let canRemove = removePath && removePath.oldPos + 1 < oldLen;\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        }\n\n        // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the old string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n        if (!canRemove || (canAdd && removePath.oldPos < addPath.oldPos)) {\n          basePath = self.addToPath(addPath, true, false, 0, options);\n        } else {\n          basePath = self.addToPath(removePath, false, true, 1, options);\n        }\n\n        newPos = self.extractCommon(basePath, newString, oldString, diagonalPath, options);\n\n        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n          // If we have hit the end of both strings, then we are done\n          return done(buildValues(self, basePath.lastComponent, newString, oldString, self.useLongestToken));\n        } else {\n          bestPath[diagonalPath] = basePath;\n          if (basePath.oldPos + 1 >= oldLen) {\n            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);\n          }\n          if (newPos + 1 >= newLen) {\n            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);\n          }\n        }\n      }\n\n      editLength++;\n    }\n\n    // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced, or until the edit length exceeds options.maxEditLength (if given),\n    // in which case it will return undefined.\n    if (callback) {\n      (function exec() {\n        setTimeout(function() {\n          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {\n            return callback();\n          }\n\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      }());\n    } else {\n      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {\n        let ret = execEditLength();\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n\n  addToPath(path, added, removed, oldPosInc, options) {\n    let last = path.lastComponent;\n    if (last && !options.oneChangePerToken && last.added === added && last.removed === removed) {\n      return {\n        oldPos: path.oldPos + oldPosInc,\n        lastComponent: {count: last.count + 1, added: added, removed: removed, previousComponent: last.previousComponent }\n      };\n    } else {\n      return {\n        oldPos: path.oldPos + oldPosInc,\n        lastComponent: {count: 1, added: added, removed: removed, previousComponent: last }\n      };\n    }\n  },\n  extractCommon(basePath, newString, oldString, diagonalPath, options) {\n    let newLen = newString.length,\n        oldLen = oldString.length,\n        oldPos = basePath.oldPos,\n        newPos = oldPos - diagonalPath,\n\n        commonCount = 0;\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldString[oldPos + 1], newString[newPos + 1], options)) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n      if (options.oneChangePerToken) {\n        basePath.lastComponent = {count: 1, previousComponent: basePath.lastComponent, added: false, removed: false};\n      }\n    }\n\n    if (commonCount && !options.oneChangePerToken) {\n      basePath.lastComponent = {count: commonCount, previousComponent: basePath.lastComponent, added: false, removed: false};\n    }\n\n    basePath.oldPos = oldPos;\n    return newPos;\n  },\n\n  equals(left, right, options) {\n    if (options.comparator) {\n      return options.comparator(left, right);\n    } else {\n      return left === right\n        || (options.ignoreCase && left.toLowerCase() === right.toLowerCase());\n    }\n  },\n  removeEmpty(array) {\n    let ret = [];\n    for (let i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n    return ret;\n  },\n  castInput(value) {\n    return value;\n  },\n  tokenize(value) {\n    return Array.from(value);\n  },\n  join(chars) {\n    return chars.join('');\n  },\n  postProcess(changeObjects) {\n    return changeObjects;\n  }\n};\n\nfunction buildValues(diff, lastComponent, newString, oldString, useLongestToken) {\n  // First we convert our linked list of components in reverse order to an\n  // array in the right order:\n  const components = [];\n  let nextComponent;\n  while (lastComponent) {\n    components.push(lastComponent);\n    nextComponent = lastComponent.previousComponent;\n    delete lastComponent.previousComponent;\n    lastComponent = nextComponent;\n  }\n  components.reverse();\n\n  let componentPos = 0,\n      componentLen = components.length,\n      newPos = 0,\n      oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    let component = components[componentPos];\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        let value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function(value, i) {\n          let oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n      newPos += component.count;\n\n      // Common case\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count;\n    }\n  }\n\n  return components;\n}\n"],"names":["Diff","buildValues","diff","lastComponent","newString","oldString","useLongestToken","components","nextComponent","push","previousComponent","reverse","componentPos","componentLen","length","newPos","oldPos","component","removed","value","join","slice","count","added","map","i","oldValue","prototype","options","arguments","undefined","callback","self","this","done","postProcess","setTimeout","castInput","removeEmpty","tokenize","newLen","oldLen","editLength","maxEditLength","Math","min","maxExecutionTime","timeout","Infinity","abortAfterTimestamp","Date","now","bestPath","extractCommon","minDiagonalToConsider","maxDiagonalToConsider","execEditLength","diagonalPath","max","basePath","removePath","addPath","canAdd","addPathNewPos","canRemove","addToPath","exec","ret","path","oldPosInc","last","oneChangePerToken","commonCount","equals","left","right","comparator","ignoreCase","toLowerCase","array","Array","from","chars","changeObjects","_exports","default"],"mappings":"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"}