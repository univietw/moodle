{"version":3,"file":"base.min.js","sources":["../../../src/jsdiff/diff/base.js"],"sourcesContent":["export default function Diff() {}\n\nDiff.prototype = {\n  diff(oldString, newString, options = {}) {\n    let callback = options.callback;\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    let self = this;\n\n    function done(value) {\n      value = self.postProcess(value, options);\n      if (callback) {\n        setTimeout(function() { callback(value); }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    }\n\n    // Allow subclasses to massage the input prior to running\n    oldString = this.castInput(oldString, options);\n    newString = this.castInput(newString, options);\n\n    oldString = this.removeEmpty(this.tokenize(oldString, options));\n    newString = this.removeEmpty(this.tokenize(newString, options));\n\n    let newLen = newString.length, oldLen = oldString.length;\n    let editLength = 1;\n    let maxEditLength = newLen + oldLen;\n    if(options.maxEditLength != null) {\n      maxEditLength = Math.min(maxEditLength, options.maxEditLength);\n    }\n    const maxExecutionTime = options.timeout ?? Infinity;\n    const abortAfterTimestamp = Date.now() + maxExecutionTime;\n\n    let bestPath = [{ oldPos: -1, lastComponent: undefined }];\n\n    // Seed editLength = 0, i.e. the content starts with the same values\n    let newPos = this.extractCommon(bestPath[0], newString, oldString, 0, options);\n    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n      // Identity per the equality and tokenizer\n      return done(buildValues(self, bestPath[0].lastComponent, newString, oldString, self.useLongestToken));\n    }\n\n    // Once we hit the right edge of the edit graph on some diagonal k, we can\n    // definitely reach the end of the edit graph in no more than k edits, so\n    // there's no point in considering any moves to diagonal k+1 any more (from\n    // which we're guaranteed to need at least k+1 more edits).\n    // Similarly, once we've reached the bottom of the edit graph, there's no\n    // point considering moves to lower diagonals.\n    // We record this fact by setting minDiagonalToConsider and\n    // maxDiagonalToConsider to some finite value once we've hit the edge of\n    // the edit graph.\n    // This optimization is not faithful to the original algorithm presented in\n    // Myers's paper, which instead pointlessly extends D-paths off the end of\n    // the edit graph - see page 7 of Myers's paper which notes this point\n    // explicitly and illustrates it with a diagram. This has major performance\n    // implications for some common scenarios. For instance, to compute a diff\n    // where the new text simply appends d characters on the end of the\n    // original text of length n, the true Myers algorithm will take O(n+d^2)\n    // time while this optimization needs only O(n+d) time.\n    let minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;\n\n    // Main worker method. checks all permutations of a given edit length for acceptance.\n    function execEditLength() {\n      for (\n        let diagonalPath = Math.max(minDiagonalToConsider, -editLength);\n        diagonalPath <= Math.min(maxDiagonalToConsider, editLength);\n        diagonalPath += 2\n      ) {\n        let basePath;\n        let removePath = bestPath[diagonalPath - 1],\n            addPath = bestPath[diagonalPath + 1];\n        if (removePath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        let canAdd = false;\n        if (addPath) {\n          // what newPos will be after we do an insertion:\n          const addPathNewPos = addPath.oldPos - diagonalPath;\n          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;\n        }\n\n        let canRemove = removePath && removePath.oldPos + 1 < oldLen;\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        }\n\n        // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the old string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n        if (!canRemove || (canAdd && removePath.oldPos < addPath.oldPos)) {\n          basePath = self.addToPath(addPath, true, false, 0, options);\n        } else {\n          basePath = self.addToPath(removePath, false, true, 1, options);\n        }\n\n        newPos = self.extractCommon(basePath, newString, oldString, diagonalPath, options);\n\n        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n          // If we have hit the end of both strings, then we are done\n          return done(buildValues(self, basePath.lastComponent, newString, oldString, self.useLongestToken));\n        } else {\n          bestPath[diagonalPath] = basePath;\n          if (basePath.oldPos + 1 >= oldLen) {\n            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);\n          }\n          if (newPos + 1 >= newLen) {\n            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);\n          }\n        }\n      }\n\n      editLength++;\n    }\n\n    // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced, or until the edit length exceeds options.maxEditLength (if given),\n    // in which case it will return undefined.\n    if (callback) {\n      (function exec() {\n        setTimeout(function() {\n          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {\n            return callback();\n          }\n\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      }());\n    } else {\n      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {\n        let ret = execEditLength();\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n\n  addToPath(path, added, removed, oldPosInc, options) {\n    let last = path.lastComponent;\n    if (last && !options.oneChangePerToken && last.added === added && last.removed === removed) {\n      return {\n        oldPos: path.oldPos + oldPosInc,\n        lastComponent: {count: last.count + 1, added: added, removed: removed, previousComponent: last.previousComponent }\n      };\n    } else {\n      return {\n        oldPos: path.oldPos + oldPosInc,\n        lastComponent: {count: 1, added: added, removed: removed, previousComponent: last }\n      };\n    }\n  },\n  extractCommon(basePath, newString, oldString, diagonalPath, options) {\n    let newLen = newString.length,\n        oldLen = oldString.length,\n        oldPos = basePath.oldPos,\n        newPos = oldPos - diagonalPath,\n\n        commonCount = 0;\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldString[oldPos + 1], newString[newPos + 1], options)) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n      if (options.oneChangePerToken) {\n        basePath.lastComponent = {count: 1, previousComponent: basePath.lastComponent, added: false, removed: false};\n      }\n    }\n\n    if (commonCount && !options.oneChangePerToken) {\n      basePath.lastComponent = {count: commonCount, previousComponent: basePath.lastComponent, added: false, removed: false};\n    }\n\n    basePath.oldPos = oldPos;\n    return newPos;\n  },\n\n  equals(left, right, options) {\n    if (options.comparator) {\n      return options.comparator(left, right);\n    } else {\n      return left === right\n        || (options.ignoreCase && left.toLowerCase() === right.toLowerCase());\n    }\n  },\n  removeEmpty(array) {\n    let ret = [];\n    for (let i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n    return ret;\n  },\n  castInput(value) {\n    return value;\n  },\n  tokenize(value) {\n    return Array.from(value);\n  },\n  join(chars) {\n    return chars.join('');\n  },\n  postProcess(changeObjects) {\n    return changeObjects;\n  }\n};\n\nfunction buildValues(diff, lastComponent, newString, oldString, useLongestToken) {\n  // First we convert our linked list of components in reverse order to an\n  // array in the right order:\n  const components = [];\n  let nextComponent;\n  while (lastComponent) {\n    components.push(lastComponent);\n    nextComponent = lastComponent.previousComponent;\n    delete lastComponent.previousComponent;\n    lastComponent = nextComponent;\n  }\n  components.reverse();\n\n  let componentPos = 0,\n      componentLen = components.length,\n      newPos = 0,\n      oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    let component = components[componentPos];\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        let value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function(value, i) {\n          let oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n      newPos += component.count;\n\n      // Common case\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count;\n    }\n  }\n\n  return components;\n}\n"],"names":["Diff","buildValues","diff","lastComponent","newString","oldString","useLongestToken","components","nextComponent","push","previousComponent","reverse","componentPos","componentLen","length","newPos","oldPos","component","removed","value","join","slice","count","added","map","i","oldValue","prototype","options","callback","self","this","done","postProcess","setTimeout","castInput","removeEmpty","tokenize","newLen","oldLen","editLength","maxEditLength","Math","min","maxExecutionTime","timeout","Infinity","abortAfterTimestamp","Date","now","bestPath","undefined","extractCommon","minDiagonalToConsider","maxDiagonalToConsider","execEditLength","diagonalPath","max","basePath","removePath","addPath","canAdd","addPathNewPos","canRemove","addToPath","exec","ret","path","oldPosInc","last","oneChangePerToken","commonCount","equals","left","right","comparator","ignoreCase","toLowerCase","array","Array","from","chars","changeObjects"],"mappings":"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"}