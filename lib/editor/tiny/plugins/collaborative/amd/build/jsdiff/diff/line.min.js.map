{"version":3,"file":"line.min.js","sources":["../../../src/jsdiff/diff/line.js"],"sourcesContent":["import Diff from './base';\nimport {generateOptions} from '../util/params';\n\nexport const lineDiff = new Diff();\nlineDiff.tokenize = function(value, options) {\n  if(options.stripTrailingCr) {\n    // remove one \\r before \\n to match GNU diff's --strip-trailing-cr behavior\n    value = value.replace(/\\r\\n/g, '\\n');\n  }\n\n  let retLines = [],\n      linesAndNewlines = value.split(/(\\n|\\r\\n)/);\n\n  // Ignore the final empty token that occurs if the string ends with a new line\n  if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n    linesAndNewlines.pop();\n  }\n\n  // Merge the content and line separators into single tokens\n  for (let i = 0; i < linesAndNewlines.length; i++) {\n    let line = linesAndNewlines[i];\n\n    if (i % 2 && !options.newlineIsToken) {\n      retLines[retLines.length - 1] += line;\n    } else {\n      retLines.push(line);\n    }\n  }\n\n  return retLines;\n};\n\nlineDiff.equals = function(left, right, options) {\n  // If we're ignoring whitespace, we need to normalise lines by stripping\n  // whitespace before checking equality. (This has an annoying interaction\n  // with newlineIsToken that requires special handling: if newlines get their\n  // own token, then we DON'T want to trim the *newline* tokens down to empty\n  // strings, since this would cause us to treat whitespace-only line content\n  // as equal to a separator between lines, which would be weird and\n  // inconsistent with the documented behavior of the options.)\n  if (options.ignoreWhitespace) {\n    if (!options.newlineIsToken || !left.includes('\\n')) {\n      left = left.trim();\n    }\n    if (!options.newlineIsToken || !right.includes('\\n')) {\n      right = right.trim();\n    }\n  } else if (options.ignoreNewlineAtEof && !options.newlineIsToken) {\n    if (left.endsWith('\\n')) {\n      left = left.slice(0, -1);\n    }\n    if (right.endsWith('\\n')) {\n      right = right.slice(0, -1);\n    }\n  }\n  return Diff.prototype.equals.call(this, left, right, options);\n};\n\nexport function diffLines(oldStr, newStr, callback) { return lineDiff.diff(oldStr, newStr, callback); }\n\n// Kept for backwards compatibility. This is a rather arbitrary wrapper method\n// that just calls `diffLines` with `ignoreWhitespace: true`. It's confusing to\n// have two ways to do exactly the same thing in the API, so we no longer\n// document this one (library users should explicitly use `diffLines` with\n// `ignoreWhitespace: true` instead) but we keep it around to maintain\n// compatibility with code that used old versions.\nexport function diffTrimmedLines(oldStr, newStr, callback) {\n  let options = generateOptions(callback, {ignoreWhitespace: true});\n  return lineDiff.diff(oldStr, newStr, options);\n}\n"],"names":["oldStr","newStr","callback","lineDiff","diff","options","ignoreWhitespace","tokenize","value","stripTrailingCr","replace","retLines","linesAndNewlines","split","length","pop","i","line","newlineIsToken","push","equals","left","right","includes","trim","ignoreNewlineAtEof","endsWith","slice","Diff","prototype","call","this"],"mappings":"iNA0D0BA,OAAQC,OAAQC,iBAAmBC,SAASC,KAAKJ,OAAQC,OAAQC,8CAQ1DF,OAAQC,OAAQC,cAC3CG,SAAU,2BAAgBH,SAAU,CAACI,kBAAkB,WACpDH,SAASC,KAAKJ,OAAQC,OAAQI,yCAjE1BF,SAAW,4FACxBA,SAASI,SAAW,SAASC,MAAOH,SAC/BA,QAAQI,kBAETD,MAAQA,MAAME,QAAQ,QAAS,WAG7BC,SAAW,GACXC,iBAAmBJ,MAAMK,MAAM,aAG9BD,iBAAiBA,iBAAiBE,OAAS,IAC9CF,iBAAiBG,UAId,IAAIC,EAAI,EAAGA,EAAIJ,iBAAiBE,OAAQE,IAAK,KAC5CC,KAAOL,iBAAiBI,GAExBA,EAAI,IAAMX,QAAQa,eACpBP,SAASA,SAASG,OAAS,IAAMG,KAEjCN,SAASQ,KAAKF,aAIXN,UAGTR,SAASiB,OAAS,SAASC,KAAMC,MAAOjB,gBAQlCA,QAAQC,kBACLD,QAAQa,gBAAmBG,KAAKE,SAAS,QAC5CF,KAAOA,KAAKG,QAETnB,QAAQa,gBAAmBI,MAAMC,SAAS,QAC7CD,MAAQA,MAAME,SAEPnB,QAAQoB,qBAAuBpB,QAAQa,iBAC5CG,KAAKK,SAAS,QAChBL,KAAOA,KAAKM,MAAM,GAAI,IAEpBL,MAAMI,SAAS,QACjBJ,MAAQA,MAAMK,MAAM,GAAI,KAGrBC,cAAKC,UAAUT,OAAOU,KAAKC,KAAMV,KAAMC,MAAOjB"}