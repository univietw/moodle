{"version":3,"file":"word.min.js","sources":["../../../src/jsdiff/diff/word.js"],"sourcesContent":["import Diff from './base';\nimport { longestCommonPrefix, longestCommonSuffix, replacePrefix, replaceSuffix, removePrefix, removeSuffix, maximumOverlap } from '../util/string';\n\n// Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode\n//\n// Ranges and exceptions:\n// Latin-1 Supplement, 0080–00FF\n//  - U+00D7  × Multiplication sign\n//  - U+00F7  ÷ Division sign\n// Latin Extended-A, 0100–017F\n// Latin Extended-B, 0180–024F\n// IPA Extensions, 0250–02AF\n// Spacing Modifier Letters, 02B0–02FF\n//  - U+02C7  ˇ &#711;  Caron\n//  - U+02D8  ˘ &#728;  Breve\n//  - U+02D9  ˙ &#729;  Dot Above\n//  - U+02DA  ˚ &#730;  Ring Above\n//  - U+02DB  ˛ &#731;  Ogonek\n//  - U+02DC  ˜ &#732;  Small Tilde\n//  - U+02DD  ˝ &#733;  Double Acute Accent\n// Latin Extended Additional, 1E00–1EFF\nconst extendedWordChars = 'a-zA-Z\\\\u{C0}-\\\\u{FF}\\\\u{D8}-\\\\u{F6}\\\\u{F8}-\\\\u{2C6}\\\\u{2C8}-\\\\u{2D7}\\\\u{2DE}-\\\\u{2FF}\\\\u{1E00}-\\\\u{1EFF}';\n\n// Each token is one of the following:\n// - A punctuation mark plus the surrounding whitespace\n// - A word plus the surrounding whitespace\n// - Pure whitespace (but only in the special case where this the entire text\n//   is just whitespace)\n//\n// We have to include surrounding whitespace in the tokens because the two\n// alternative approaches produce horribly broken results:\n// * If we just discard the whitespace, we can't fully reproduce the original\n//   text from the sequence of tokens and any attempt to render the diff will\n//   get the whitespace wrong.\n// * If we have separate tokens for whitespace, then in a typical text every\n//   second token will be a single space character. But this often results in\n//   the optimal diff between two texts being a perverse one that preserves\n//   the spaces between words but deletes and reinserts actual common words.\n//   See https://github.com/kpdecker/jsdiff/issues/160#issuecomment-1866099640\n//   for an example.\n//\n// Keeping the surrounding whitespace of course has implications for .equals\n// and .join, not just .tokenize.\n\n// This regex does NOT fully implement the tokenization rules described above.\n// Instead, it gives runs of whitespace their own \"token\". The tokenize method\n// then handles stitching whitespace tokens onto adjacent word or punctuation\n// tokens.\nconst tokenizeIncludingWhitespace = new RegExp(`[${extendedWordChars}]+|\\\\s+|[^${extendedWordChars}]`, 'ug');\n\nexport const wordDiff = new Diff();\nwordDiff.equals = function(left, right, options) {\n  if (options.ignoreCase) {\n    left = left.toLowerCase();\n    right = right.toLowerCase();\n  }\n\n  return left.trim() === right.trim();\n};\n\nwordDiff.tokenize = function(value, options = {}) {\n  let parts;\n  if (options.intlSegmenter) {\n    if (options.intlSegmenter.resolvedOptions().granularity != 'word') {\n      throw new Error('The segmenter passed must have a granularity of \"word\"');\n    }\n    parts = Array.from(options.intlSegmenter.segment(value), segment => segment.segment);\n  } else {\n    parts = value.match(tokenizeIncludingWhitespace) || [];\n  }\n  const tokens = [];\n  let prevPart = null;\n  parts.forEach(part => {\n    if ((/\\s/).test(part)) {\n      if (prevPart == null) {\n        tokens.push(part);\n      } else {\n        tokens.push(tokens.pop() + part);\n      }\n    } else if ((/\\s/).test(prevPart)) {\n      if (tokens[tokens.length - 1] == prevPart) {\n        tokens.push(tokens.pop() + part);\n      } else {\n        tokens.push(prevPart + part);\n      }\n    } else {\n      tokens.push(part);\n    }\n\n    prevPart = part;\n  });\n  return tokens;\n};\n\nwordDiff.join = function(tokens) {\n  // Tokens being joined here will always have appeared consecutively in the\n  // same text, so we can simply strip off the leading whitespace from all the\n  // tokens except the first (and except any whitespace-only tokens - but such\n  // a token will always be the first and only token anyway) and then join them\n  // and the whitespace around words and punctuation will end up correct.\n  return tokens.map((token, i) => {\n    if (i == 0) {\n      return token;\n    } else {\n      return token.replace((/^\\s+/), '');\n    }\n  }).join('');\n};\n\nwordDiff.postProcess = function(changes, options) {\n  if (!changes || options.oneChangePerToken) {\n    return changes;\n  }\n\n  let lastKeep = null;\n  // Change objects representing any insertion or deletion since the last\n  // \"keep\" change object. There can be at most one of each.\n  let insertion = null;\n  let deletion = null;\n  changes.forEach(change => {\n    if (change.added) {\n      insertion = change;\n    } else if (change.removed) {\n      deletion = change;\n    } else {\n      if (insertion || deletion) { // May be false at start of text\n        dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, change);\n      }\n      lastKeep = change;\n      insertion = null;\n      deletion = null;\n    }\n  });\n  if (insertion || deletion) {\n    dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, null);\n  }\n  return changes;\n};\n\nexport function diffWords(oldStr, newStr, options) {\n  // This option has never been documented and never will be (it's clearer to\n  // just call `diffWordsWithSpace` directly if you need that behavior), but\n  // has existed in jsdiff for a long time, so we retain support for it here\n  // for the sake of backwards compatibility.\n  if (options?.ignoreWhitespace != null && !options.ignoreWhitespace) {\n    return diffWordsWithSpace(oldStr, newStr, options);\n  }\n\n  return wordDiff.diff(oldStr, newStr, options);\n}\n\nfunction dedupeWhitespaceInChangeObjects(startKeep, deletion, insertion, endKeep) {\n  // Before returning, we tidy up the leading and trailing whitespace of the\n  // change objects to eliminate cases where trailing whitespace in one object\n  // is repeated as leading whitespace in the next.\n  // Below are examples of the outcomes we want here to explain the code.\n  // I=insert, K=keep, D=delete\n  // 1. diffing 'foo bar baz' vs 'foo baz'\n  //    Prior to cleanup, we have K:'foo ' D:' bar ' K:' baz'\n  //    After cleanup, we want:   K:'foo ' D:'bar ' K:'baz'\n  //\n  // 2. Diffing 'foo bar baz' vs 'foo qux baz'\n  //    Prior to cleanup, we have K:'foo ' D:' bar ' I:' qux ' K:' baz'\n  //    After cleanup, we want K:'foo ' D:'bar' I:'qux' K:' baz'\n  //\n  // 3. Diffing 'foo\\nbar baz' vs 'foo baz'\n  //    Prior to cleanup, we have K:'foo ' D:'\\nbar ' K:' baz'\n  //    After cleanup, we want K'foo' D:'\\nbar' K:' baz'\n  //\n  // 4. Diffing 'foo baz' vs 'foo\\nbar baz'\n  //    Prior to cleanup, we have K:'foo\\n' I:'\\nbar ' K:' baz'\n  //    After cleanup, we ideally want K'foo' I:'\\nbar' K:' baz'\n  //    but don't actually manage this currently (the pre-cleanup change\n  //    objects don't contain enough information to make it possible).\n  //\n  // 5. Diffing 'foo   bar baz' vs 'foo  baz'\n  //    Prior to cleanup, we have K:'foo  ' D:'   bar ' K:'  baz'\n  //    After cleanup, we want K:'foo  ' D:' bar ' K:'baz'\n  //\n  // Our handling is unavoidably imperfect in the case where there's a single\n  // indel between keeps and the whitespace has changed. For instance, consider\n  // diffing 'foo\\tbar\\nbaz' vs 'foo baz'. Unless we create an extra change\n  // object to represent the insertion of the space character (which isn't even\n  // a token), we have no way to avoid losing information about the texts'\n  // original whitespace in the result we return. Still, we do our best to\n  // output something that will look sensible if we e.g. print it with\n  // insertions in green and deletions in red.\n\n  // Between two \"keep\" change objects (or before the first or after the last\n  // change object), we can have either:\n  // * A \"delete\" followed by an \"insert\"\n  // * Just an \"insert\"\n  // * Just a \"delete\"\n  // We handle the three cases separately.\n  if (deletion && insertion) {\n    const oldWsPrefix = deletion.value.match(/^\\s*/)[0];\n    const oldWsSuffix = deletion.value.match(/\\s*$/)[0];\n    const newWsPrefix = insertion.value.match(/^\\s*/)[0];\n    const newWsSuffix = insertion.value.match(/\\s*$/)[0];\n\n    if (startKeep) {\n      const commonWsPrefix = longestCommonPrefix(oldWsPrefix, newWsPrefix);\n      startKeep.value = replaceSuffix(startKeep.value, newWsPrefix, commonWsPrefix);\n      deletion.value = removePrefix(deletion.value, commonWsPrefix);\n      insertion.value = removePrefix(insertion.value, commonWsPrefix);\n    }\n    if (endKeep) {\n      const commonWsSuffix = longestCommonSuffix(oldWsSuffix, newWsSuffix);\n      endKeep.value = replacePrefix(endKeep.value, newWsSuffix, commonWsSuffix);\n      deletion.value = removeSuffix(deletion.value, commonWsSuffix);\n      insertion.value = removeSuffix(insertion.value, commonWsSuffix);\n    }\n  } else if (insertion) {\n    // The whitespaces all reflect what was in the new text rather than\n    // the old, so we essentially have no information about whitespace\n    // insertion or deletion. We just want to dedupe the whitespace.\n    // We do that by having each change object keep its trailing\n    // whitespace and deleting duplicate leading whitespace where\n    // present.\n    if (startKeep) {\n      insertion.value = insertion.value.replace(/^\\s*/, '');\n    }\n    if (endKeep) {\n      endKeep.value = endKeep.value.replace(/^\\s*/, '');\n    }\n  // otherwise we've got a deletion and no insertion\n  } else if (startKeep && endKeep) {\n    const newWsFull = endKeep.value.match(/^\\s*/)[0],\n        delWsStart = deletion.value.match(/^\\s*/)[0],\n        delWsEnd = deletion.value.match(/\\s*$/)[0];\n\n    // Any whitespace that comes straight after startKeep in both the old and\n    // new texts, assign to startKeep and remove from the deletion.\n    const newWsStart = longestCommonPrefix(newWsFull, delWsStart);\n    deletion.value = removePrefix(deletion.value, newWsStart);\n\n    // Any whitespace that comes straight before endKeep in both the old and\n    // new texts, and hasn't already been assigned to startKeep, assign to\n    // endKeep and remove from the deletion.\n    const newWsEnd = longestCommonSuffix(\n      removePrefix(newWsFull, newWsStart),\n      delWsEnd\n    );\n    deletion.value = removeSuffix(deletion.value, newWsEnd);\n    endKeep.value = replacePrefix(endKeep.value, newWsFull, newWsEnd);\n\n    // If there's any whitespace from the new text that HASN'T already been\n    // assigned, assign it to the start:\n    startKeep.value = replaceSuffix(\n      startKeep.value,\n      newWsFull,\n      newWsFull.slice(0, newWsFull.length - newWsEnd.length)\n    );\n  } else if (endKeep) {\n    // We are at the start of the text. Preserve all the whitespace on\n    // endKeep, and just remove whitespace from the end of deletion to the\n    // extent that it overlaps with the start of endKeep.\n    const endKeepWsPrefix = endKeep.value.match(/^\\s*/)[0];\n    const deletionWsSuffix = deletion.value.match(/\\s*$/)[0];\n    const overlap = maximumOverlap(deletionWsSuffix, endKeepWsPrefix);\n    deletion.value = removeSuffix(deletion.value, overlap);\n  } else if (startKeep) {\n    // We are at the END of the text. Preserve all the whitespace on\n    // startKeep, and just remove whitespace from the start of deletion to\n    // the extent that it overlaps with the end of startKeep.\n    const startKeepWsSuffix = startKeep.value.match(/\\s*$/)[0];\n    const deletionWsPrefix = deletion.value.match(/^\\s*/)[0];\n    const overlap = maximumOverlap(startKeepWsSuffix, deletionWsPrefix);\n    deletion.value = removePrefix(deletion.value, overlap);\n  }\n}\n\n\nexport const wordWithSpaceDiff = new Diff();\nwordWithSpaceDiff.tokenize = function(value) {\n  // Slightly different to the tokenizeIncludingWhitespace regex used above in\n  // that this one treats each individual newline as a distinct tokens, rather\n  // than merging them into other surrounding whitespace. This was requested\n  // in https://github.com/kpdecker/jsdiff/issues/180 &\n  //    https://github.com/kpdecker/jsdiff/issues/211\n  const regex = new RegExp(`(\\\\r?\\\\n)|[${extendedWordChars}]+|[^\\\\S\\\\n\\\\r]+|[^${extendedWordChars}]`, 'ug');\n  return value.match(regex) || [];\n};\nexport function diffWordsWithSpace(oldStr, newStr, options) {\n  return wordWithSpaceDiff.diff(oldStr, newStr, options);\n}\n"],"names":["e","oldStr","newStr","options","ignoreWhitespace","diffWordsWithSpace","wordDiff","diff","_base","__esModule","default","extendedWordChars","tokenizeIncludingWhitespace","RegExp","_exports","Diff","dedupeWhitespaceInChangeObjects","startKeep","deletion","insertion","endKeep","oldWsPrefix","value","match","oldWsSuffix","newWsPrefix","newWsSuffix","commonWsPrefix","longestCommonPrefix","replaceSuffix","removePrefix","commonWsSuffix","longestCommonSuffix","replacePrefix","removeSuffix","replace","newWsFull","delWsStart","delWsEnd","newWsStart","newWsEnd","slice","length","endKeepWsPrefix","deletionWsSuffix","overlap","maximumOverlap","startKeepWsSuffix","deletionWsPrefix","equals","left","right","ignoreCase","toLowerCase","trim","tokenize","parts","arguments","undefined","intlSegmenter","resolvedOptions","granularity","Error","Array","from","segment","tokens","prevPart","forEach","part","test","push","pop","join","map","token","i","postProcess","changes","oneChangePerToken","lastKeep","change","added","removed","wordWithSpaceDiff","regex"],"mappings":"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"}