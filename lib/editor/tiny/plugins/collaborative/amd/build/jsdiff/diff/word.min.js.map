{"version":3,"file":"word.min.js","sources":["../../../src/jsdiff/diff/word.js"],"sourcesContent":["import Diff from './base';\nimport { longestCommonPrefix, longestCommonSuffix, replacePrefix, replaceSuffix, removePrefix, removeSuffix, maximumOverlap } from '../util/string';\n\n// Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode\n//\n// Ranges and exceptions:\n// Latin-1 Supplement, 0080–00FF\n//  - U+00D7  × Multiplication sign\n//  - U+00F7  ÷ Division sign\n// Latin Extended-A, 0100–017F\n// Latin Extended-B, 0180–024F\n// IPA Extensions, 0250–02AF\n// Spacing Modifier Letters, 02B0–02FF\n//  - U+02C7  ˇ &#711;  Caron\n//  - U+02D8  ˘ &#728;  Breve\n//  - U+02D9  ˙ &#729;  Dot Above\n//  - U+02DA  ˚ &#730;  Ring Above\n//  - U+02DB  ˛ &#731;  Ogonek\n//  - U+02DC  ˜ &#732;  Small Tilde\n//  - U+02DD  ˝ &#733;  Double Acute Accent\n// Latin Extended Additional, 1E00–1EFF\nconst extendedWordChars = 'a-zA-Z\\\\u{C0}-\\\\u{FF}\\\\u{D8}-\\\\u{F6}\\\\u{F8}-\\\\u{2C6}\\\\u{2C8}-\\\\u{2D7}\\\\u{2DE}-\\\\u{2FF}\\\\u{1E00}-\\\\u{1EFF}';\n\n// Each token is one of the following:\n// - A punctuation mark plus the surrounding whitespace\n// - A word plus the surrounding whitespace\n// - Pure whitespace (but only in the special case where this the entire text\n//   is just whitespace)\n//\n// We have to include surrounding whitespace in the tokens because the two\n// alternative approaches produce horribly broken results:\n// * If we just discard the whitespace, we can't fully reproduce the original\n//   text from the sequence of tokens and any attempt to render the diff will\n//   get the whitespace wrong.\n// * If we have separate tokens for whitespace, then in a typical text every\n//   second token will be a single space character. But this often results in\n//   the optimal diff between two texts being a perverse one that preserves\n//   the spaces between words but deletes and reinserts actual common words.\n//   See https://github.com/kpdecker/jsdiff/issues/160#issuecomment-1866099640\n//   for an example.\n//\n// Keeping the surrounding whitespace of course has implications for .equals\n// and .join, not just .tokenize.\n\n// This regex does NOT fully implement the tokenization rules described above.\n// Instead, it gives runs of whitespace their own \"token\". The tokenize method\n// then handles stitching whitespace tokens onto adjacent word or punctuation\n// tokens.\nconst tokenizeIncludingWhitespace = new RegExp(`[${extendedWordChars}]+|\\\\s+|[^${extendedWordChars}]`, 'ug');\n\nexport const wordDiff = new Diff();\nwordDiff.equals = function(left, right, options) {\n  if (options.ignoreCase) {\n    left = left.toLowerCase();\n    right = right.toLowerCase();\n  }\n\n  return left.trim() === right.trim();\n};\n\nwordDiff.tokenize = function(value, options = {}) {\n  let parts;\n  if (options.intlSegmenter) {\n    if (options.intlSegmenter.resolvedOptions().granularity != 'word') {\n      throw new Error('The segmenter passed must have a granularity of \"word\"');\n    }\n    parts = Array.from(options.intlSegmenter.segment(value), segment => segment.segment);\n  } else {\n    parts = value.match(tokenizeIncludingWhitespace) || [];\n  }\n  const tokens = [];\n  let prevPart = null;\n  parts.forEach(part => {\n    if ((/\\s/).test(part)) {\n      if (prevPart == null) {\n        tokens.push(part);\n      } else {\n        tokens.push(tokens.pop() + part);\n      }\n    } else if ((/\\s/).test(prevPart)) {\n      if (tokens[tokens.length - 1] == prevPart) {\n        tokens.push(tokens.pop() + part);\n      } else {\n        tokens.push(prevPart + part);\n      }\n    } else {\n      tokens.push(part);\n    }\n\n    prevPart = part;\n  });\n  return tokens;\n};\n\nwordDiff.join = function(tokens) {\n  // Tokens being joined here will always have appeared consecutively in the\n  // same text, so we can simply strip off the leading whitespace from all the\n  // tokens except the first (and except any whitespace-only tokens - but such\n  // a token will always be the first and only token anyway) and then join them\n  // and the whitespace around words and punctuation will end up correct.\n  return tokens.map((token, i) => {\n    if (i == 0) {\n      return token;\n    } else {\n      return token.replace((/^\\s+/), '');\n    }\n  }).join('');\n};\n\nwordDiff.postProcess = function(changes, options) {\n  if (!changes || options.oneChangePerToken) {\n    return changes;\n  }\n\n  let lastKeep = null;\n  // Change objects representing any insertion or deletion since the last\n  // \"keep\" change object. There can be at most one of each.\n  let insertion = null;\n  let deletion = null;\n  changes.forEach(change => {\n    if (change.added) {\n      insertion = change;\n    } else if (change.removed) {\n      deletion = change;\n    } else {\n      if (insertion || deletion) { // May be false at start of text\n        dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, change);\n      }\n      lastKeep = change;\n      insertion = null;\n      deletion = null;\n    }\n  });\n  if (insertion || deletion) {\n    dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, null);\n  }\n  return changes;\n};\n\nexport function diffWords(oldStr, newStr, options) {\n  // This option has never been documented and never will be (it's clearer to\n  // just call `diffWordsWithSpace` directly if you need that behavior), but\n  // has existed in jsdiff for a long time, so we retain support for it here\n  // for the sake of backwards compatibility.\n  if (options?.ignoreWhitespace != null && !options.ignoreWhitespace) {\n    return diffWordsWithSpace(oldStr, newStr, options);\n  }\n\n  return wordDiff.diff(oldStr, newStr, options);\n}\n\nfunction dedupeWhitespaceInChangeObjects(startKeep, deletion, insertion, endKeep) {\n  // Before returning, we tidy up the leading and trailing whitespace of the\n  // change objects to eliminate cases where trailing whitespace in one object\n  // is repeated as leading whitespace in the next.\n  // Below are examples of the outcomes we want here to explain the code.\n  // I=insert, K=keep, D=delete\n  // 1. diffing 'foo bar baz' vs 'foo baz'\n  //    Prior to cleanup, we have K:'foo ' D:' bar ' K:' baz'\n  //    After cleanup, we want:   K:'foo ' D:'bar ' K:'baz'\n  //\n  // 2. Diffing 'foo bar baz' vs 'foo qux baz'\n  //    Prior to cleanup, we have K:'foo ' D:' bar ' I:' qux ' K:' baz'\n  //    After cleanup, we want K:'foo ' D:'bar' I:'qux' K:' baz'\n  //\n  // 3. Diffing 'foo\\nbar baz' vs 'foo baz'\n  //    Prior to cleanup, we have K:'foo ' D:'\\nbar ' K:' baz'\n  //    After cleanup, we want K'foo' D:'\\nbar' K:' baz'\n  //\n  // 4. Diffing 'foo baz' vs 'foo\\nbar baz'\n  //    Prior to cleanup, we have K:'foo\\n' I:'\\nbar ' K:' baz'\n  //    After cleanup, we ideally want K'foo' I:'\\nbar' K:' baz'\n  //    but don't actually manage this currently (the pre-cleanup change\n  //    objects don't contain enough information to make it possible).\n  //\n  // 5. Diffing 'foo   bar baz' vs 'foo  baz'\n  //    Prior to cleanup, we have K:'foo  ' D:'   bar ' K:'  baz'\n  //    After cleanup, we want K:'foo  ' D:' bar ' K:'baz'\n  //\n  // Our handling is unavoidably imperfect in the case where there's a single\n  // indel between keeps and the whitespace has changed. For instance, consider\n  // diffing 'foo\\tbar\\nbaz' vs 'foo baz'. Unless we create an extra change\n  // object to represent the insertion of the space character (which isn't even\n  // a token), we have no way to avoid losing information about the texts'\n  // original whitespace in the result we return. Still, we do our best to\n  // output something that will look sensible if we e.g. print it with\n  // insertions in green and deletions in red.\n\n  // Between two \"keep\" change objects (or before the first or after the last\n  // change object), we can have either:\n  // * A \"delete\" followed by an \"insert\"\n  // * Just an \"insert\"\n  // * Just a \"delete\"\n  // We handle the three cases separately.\n  if (deletion && insertion) {\n    const oldWsPrefix = deletion.value.match(/^\\s*/)[0];\n    const oldWsSuffix = deletion.value.match(/\\s*$/)[0];\n    const newWsPrefix = insertion.value.match(/^\\s*/)[0];\n    const newWsSuffix = insertion.value.match(/\\s*$/)[0];\n\n    if (startKeep) {\n      const commonWsPrefix = longestCommonPrefix(oldWsPrefix, newWsPrefix);\n      startKeep.value = replaceSuffix(startKeep.value, newWsPrefix, commonWsPrefix);\n      deletion.value = removePrefix(deletion.value, commonWsPrefix);\n      insertion.value = removePrefix(insertion.value, commonWsPrefix);\n    }\n    if (endKeep) {\n      const commonWsSuffix = longestCommonSuffix(oldWsSuffix, newWsSuffix);\n      endKeep.value = replacePrefix(endKeep.value, newWsSuffix, commonWsSuffix);\n      deletion.value = removeSuffix(deletion.value, commonWsSuffix);\n      insertion.value = removeSuffix(insertion.value, commonWsSuffix);\n    }\n  } else if (insertion) {\n    // The whitespaces all reflect what was in the new text rather than\n    // the old, so we essentially have no information about whitespace\n    // insertion or deletion. We just want to dedupe the whitespace.\n    // We do that by having each change object keep its trailing\n    // whitespace and deleting duplicate leading whitespace where\n    // present.\n    if (startKeep) {\n      insertion.value = insertion.value.replace(/^\\s*/, '');\n    }\n    if (endKeep) {\n      endKeep.value = endKeep.value.replace(/^\\s*/, '');\n    }\n  // otherwise we've got a deletion and no insertion\n  } else if (startKeep && endKeep) {\n    const newWsFull = endKeep.value.match(/^\\s*/)[0],\n        delWsStart = deletion.value.match(/^\\s*/)[0],\n        delWsEnd = deletion.value.match(/\\s*$/)[0];\n\n    // Any whitespace that comes straight after startKeep in both the old and\n    // new texts, assign to startKeep and remove from the deletion.\n    const newWsStart = longestCommonPrefix(newWsFull, delWsStart);\n    deletion.value = removePrefix(deletion.value, newWsStart);\n\n    // Any whitespace that comes straight before endKeep in both the old and\n    // new texts, and hasn't already been assigned to startKeep, assign to\n    // endKeep and remove from the deletion.\n    const newWsEnd = longestCommonSuffix(\n      removePrefix(newWsFull, newWsStart),\n      delWsEnd\n    );\n    deletion.value = removeSuffix(deletion.value, newWsEnd);\n    endKeep.value = replacePrefix(endKeep.value, newWsFull, newWsEnd);\n\n    // If there's any whitespace from the new text that HASN'T already been\n    // assigned, assign it to the start:\n    startKeep.value = replaceSuffix(\n      startKeep.value,\n      newWsFull,\n      newWsFull.slice(0, newWsFull.length - newWsEnd.length)\n    );\n  } else if (endKeep) {\n    // We are at the start of the text. Preserve all the whitespace on\n    // endKeep, and just remove whitespace from the end of deletion to the\n    // extent that it overlaps with the start of endKeep.\n    const endKeepWsPrefix = endKeep.value.match(/^\\s*/)[0];\n    const deletionWsSuffix = deletion.value.match(/\\s*$/)[0];\n    const overlap = maximumOverlap(deletionWsSuffix, endKeepWsPrefix);\n    deletion.value = removeSuffix(deletion.value, overlap);\n  } else if (startKeep) {\n    // We are at the END of the text. Preserve all the whitespace on\n    // startKeep, and just remove whitespace from the start of deletion to\n    // the extent that it overlaps with the end of startKeep.\n    const startKeepWsSuffix = startKeep.value.match(/\\s*$/)[0];\n    const deletionWsPrefix = deletion.value.match(/^\\s*/)[0];\n    const overlap = maximumOverlap(startKeepWsSuffix, deletionWsPrefix);\n    deletion.value = removePrefix(deletion.value, overlap);\n  }\n}\n\n\nexport const wordWithSpaceDiff = new Diff();\nwordWithSpaceDiff.tokenize = function(value) {\n  // Slightly different to the tokenizeIncludingWhitespace regex used above in\n  // that this one treats each individual newline as a distinct tokens, rather\n  // than merging them into other surrounding whitespace. This was requested\n  // in https://github.com/kpdecker/jsdiff/issues/180 &\n  //    https://github.com/kpdecker/jsdiff/issues/211\n  const regex = new RegExp(`(\\\\r?\\\\n)|[${extendedWordChars}]+|[^\\\\S\\\\n\\\\r]+|[^${extendedWordChars}]`, 'ug');\n  return value.match(regex) || [];\n};\nexport function diffWordsWithSpace(oldStr, newStr, options) {\n  return wordWithSpaceDiff.diff(oldStr, newStr, options);\n}\n"],"names":["oldStr","newStr","options","ignoreWhitespace","diffWordsWithSpace","wordDiff","diff","extendedWordChars","tokenizeIncludingWhitespace","RegExp","Diff","dedupeWhitespaceInChangeObjects","startKeep","deletion","insertion","endKeep","oldWsPrefix","value","match","oldWsSuffix","newWsPrefix","newWsSuffix","commonWsPrefix","commonWsSuffix","replace","newWsFull","delWsStart","delWsEnd","newWsStart","newWsEnd","slice","length","endKeepWsPrefix","deletionWsSuffix","overlap","startKeepWsSuffix","deletionWsPrefix","equals","left","right","ignoreCase","toLowerCase","trim","tokenize","parts","intlSegmenter","resolvedOptions","granularity","Error","Array","from","segment","tokens","prevPart","forEach","part","test","push","pop","join","map","token","i","postProcess","changes","oneChangePerToken","lastKeep","change","added","removed","wordWithSpaceDiff","regex"],"mappings":"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"}