define("tiny_collaborative/jsdiff/patch/create",["exports","../diff/line"],(function(_exports,_line){function structuredPatch(oldFileName,newFileName,oldStr,newStr,oldHeader,newHeader,options){if(options||(options={}),"function"==typeof options&&(options={callback:options}),void 0===options.context&&(options.context=4),options.newlineIsToken)throw new Error("newlineIsToken may not be used with patch-generation functions, only with diffing functions");if(!options.callback)return diffLinesResultToPatch((0,_line.diffLines)(oldStr,newStr,options));{const{callback:callback}=options;(0,_line.diffLines)(oldStr,newStr,{...options,callback:diff=>{const patch=diffLinesResultToPatch(diff);callback(patch)}})}function diffLinesResultToPatch(diff){if(!diff)return;function contextLines(lines){return lines.map((function(entry){return" "+entry}))}diff.push({value:"",lines:[]});let hunks=[],oldRangeStart=0,newRangeStart=0,curRange=[],oldLine=1,newLine=1;for(let i=0;i<diff.length;i++){const current=diff[i],lines=current.lines||splitLines(current.value);if(current.lines=lines,current.added||current.removed){if(!oldRangeStart){const prev=diff[i-1];oldRangeStart=oldLine,newRangeStart=newLine,prev&&(curRange=options.context>0?contextLines(prev.lines.slice(-options.context)):[],oldRangeStart-=curRange.length,newRangeStart-=curRange.length)}curRange.push(...lines.map((function(entry){return(current.added?"+":"-")+entry}))),current.added?newLine+=lines.length:oldLine+=lines.length}else{if(oldRangeStart)if(lines.length<=2*options.context&&i<diff.length-2)curRange.push(...contextLines(lines));else{let contextSize=Math.min(lines.length,options.context);curRange.push(...contextLines(lines.slice(0,contextSize)));let hunk={oldStart:oldRangeStart,oldLines:oldLine-oldRangeStart+contextSize,newStart:newRangeStart,newLines:newLine-newRangeStart+contextSize,lines:curRange};hunks.push(hunk),oldRangeStart=0,newRangeStart=0,curRange=[]}oldLine+=lines.length,newLine+=lines.length}}for(const hunk of hunks)for(let i=0;i<hunk.lines.length;i++)hunk.lines[i].endsWith("\n")?hunk.lines[i]=hunk.lines[i].slice(0,-1):(hunk.lines.splice(i+1,0,"\\ No newline at end of file"),i++);return{oldFileName:oldFileName,newFileName:newFileName,oldHeader:oldHeader,newHeader:newHeader,hunks:hunks}}}function formatPatch(diff){if(Array.isArray(diff))return diff.map(formatPatch).join("\n");const ret=[];diff.oldFileName==diff.newFileName&&ret.push("Index: "+diff.oldFileName),ret.push("==================================================================="),ret.push("--- "+diff.oldFileName+(void 0===diff.oldHeader?"":"\t"+diff.oldHeader)),ret.push("+++ "+diff.newFileName+(void 0===diff.newHeader?"":"\t"+diff.newHeader));for(let i=0;i<diff.hunks.length;i++){const hunk=diff.hunks[i];0===hunk.oldLines&&(hunk.oldStart-=1),0===hunk.newLines&&(hunk.newStart-=1),ret.push("@@ -"+hunk.oldStart+","+hunk.oldLines+" +"+hunk.newStart+","+hunk.newLines+" @@"),ret.push.apply(ret,hunk.lines)}return ret.join("\n")+"\n"}function createTwoFilesPatch(oldFileName,newFileName,oldStr,newStr,oldHeader,newHeader,options){if("function"==typeof options&&(options={callback:options}),!options?.callback){const patchObj=structuredPatch(oldFileName,newFileName,oldStr,newStr,oldHeader,newHeader,options);if(!patchObj)return;return formatPatch(patchObj)}{const{callback:callback}=options;structuredPatch(oldFileName,newFileName,oldStr,newStr,oldHeader,newHeader,{...options,callback:patchObj=>{patchObj?callback(formatPatch(patchObj)):callback()}})}}function splitLines(text){const hasTrailingNl=text.endsWith("\n"),result=text.split("\n").map((line=>line+"\n"));return hasTrailingNl?result.pop():result.push(result.pop().slice(0,-1)),result}Object.defineProperty(_exports,"__esModule",{value:!0}),_exports.createPatch=function(fileName,oldStr,newStr,oldHeader,newHeader,options){return createTwoFilesPatch(fileName,fileName,oldStr,newStr,oldHeader,newHeader,options)},_exports.createTwoFilesPatch=createTwoFilesPatch,_exports.formatPatch=formatPatch,_exports.structuredPatch=structuredPatch}));

//# sourceMappingURL=create.min.js.map