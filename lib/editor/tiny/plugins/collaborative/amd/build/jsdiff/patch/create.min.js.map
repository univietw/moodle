{"version":3,"file":"create.min.js","sources":["../../../src/jsdiff/patch/create.js"],"sourcesContent":["import {diffLines} from '../diff/line';\n\nexport function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  if (!options) {\n    options = {};\n  }\n  if (typeof options === 'function') {\n    options = {callback: options};\n  }\n  if (typeof options.context === 'undefined') {\n    options.context = 4;\n  }\n  if (options.newlineIsToken) {\n    throw new Error('newlineIsToken may not be used with patch-generation functions, only with diffing functions');\n  }\n\n  if (!options.callback) {\n    return diffLinesResultToPatch(diffLines(oldStr, newStr, options));\n  } else {\n    const {callback} = options;\n    diffLines(\n      oldStr,\n      newStr,\n      {\n        ...options,\n        callback: (diff) => {\n          const patch = diffLinesResultToPatch(diff);\n          callback(patch);\n        }\n      }\n    );\n  }\n\n  function diffLinesResultToPatch(diff) {\n    // STEP 1: Build up the patch with no \"\\ No newline at end of file\" lines and with the arrays\n    //         of lines containing trailing newline characters. We'll tidy up later...\n\n    if(!diff) {\n      return;\n    }\n\n    diff.push({value: '', lines: []}); // Append an empty value to make cleanup easier\n\n    function contextLines(lines) {\n      return lines.map(function(entry) { return ' ' + entry; });\n    }\n\n    let hunks = [];\n    let oldRangeStart = 0, newRangeStart = 0, curRange = [],\n        oldLine = 1, newLine = 1;\n    for (let i = 0; i < diff.length; i++) {\n      const current = diff[i],\n            lines = current.lines || splitLines(current.value);\n      current.lines = lines;\n\n      if (current.added || current.removed) {\n        // If we have previous context, start with that\n        if (!oldRangeStart) {\n          const prev = diff[i - 1];\n          oldRangeStart = oldLine;\n          newRangeStart = newLine;\n\n          if (prev) {\n            curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n            oldRangeStart -= curRange.length;\n            newRangeStart -= curRange.length;\n          }\n        }\n\n        // Output our changes\n        curRange.push(... lines.map(function(entry) {\n          return (current.added ? '+' : '-') + entry;\n        }));\n\n        // Track the updated file position\n        if (current.added) {\n          newLine += lines.length;\n        } else {\n          oldLine += lines.length;\n        }\n      } else {\n        // Identical context lines. Track line changes\n        if (oldRangeStart) {\n          // Close out any changes that have been output (or join overlapping)\n          if (lines.length <= options.context * 2 && i < diff.length - 2) {\n            // Overlapping\n            curRange.push(... contextLines(lines));\n          } else {\n            // end the range and output\n            let contextSize = Math.min(lines.length, options.context);\n            curRange.push(... contextLines(lines.slice(0, contextSize)));\n\n            let hunk = {\n              oldStart: oldRangeStart,\n              oldLines: (oldLine - oldRangeStart + contextSize),\n              newStart: newRangeStart,\n              newLines: (newLine - newRangeStart + contextSize),\n              lines: curRange\n            };\n            hunks.push(hunk);\n\n            oldRangeStart = 0;\n            newRangeStart = 0;\n            curRange = [];\n          }\n        }\n        oldLine += lines.length;\n        newLine += lines.length;\n      }\n    }\n\n    // Step 2: eliminate the trailing `\\n` from each line of each hunk, and, where needed, add\n    //         \"\\ No newline at end of file\".\n    for (const hunk of hunks) {\n      for (let i = 0; i < hunk.lines.length; i++) {\n        if (hunk.lines[i].endsWith('\\n')) {\n          hunk.lines[i] = hunk.lines[i].slice(0, -1);\n        } else {\n          hunk.lines.splice(i + 1, 0, '\\\\ No newline at end of file');\n          i++; // Skip the line we just added, then continue iterating\n        }\n      }\n    }\n\n    return {\n      oldFileName: oldFileName, newFileName: newFileName,\n      oldHeader: oldHeader, newHeader: newHeader,\n      hunks: hunks\n    };\n  }\n}\n\nexport function formatPatch(diff) {\n  if (Array.isArray(diff)) {\n    return diff.map(formatPatch).join('\\n');\n  }\n\n  const ret = [];\n  if (diff.oldFileName == diff.newFileName) {\n    ret.push('Index: ' + diff.oldFileName);\n  }\n  ret.push('===================================================================');\n  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n  for (let i = 0; i < diff.hunks.length; i++) {\n    const hunk = diff.hunks[i];\n    // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n    if (hunk.oldLines === 0) {\n      hunk.oldStart -= 1;\n    }\n    if (hunk.newLines === 0) {\n      hunk.newStart -= 1;\n    }\n    ret.push(\n      '@@ -' + hunk.oldStart + ',' + hunk.oldLines\n      + ' +' + hunk.newStart + ',' + hunk.newLines\n      + ' @@'\n    );\n    ret.push.apply(ret, hunk.lines);\n  }\n\n  return ret.join('\\n') + '\\n';\n}\n\nexport function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  if (typeof options === 'function') {\n    options = {callback: options};\n  }\n\n  if (!options?.callback) {\n    const patchObj = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);\n    if (!patchObj) {\n      return;\n    }\n    return formatPatch(patchObj);\n  } else {\n    const {callback} = options;\n    structuredPatch(\n      oldFileName,\n      newFileName,\n      oldStr,\n      newStr,\n      oldHeader,\n      newHeader,\n      {\n        ...options,\n        callback: patchObj => {\n          if (!patchObj) {\n            callback();\n          } else {\n            callback(formatPatch(patchObj));\n          }\n        }\n      }\n    );\n  }\n}\n\nexport function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}\n\n/**\n * Split `text` into an array of lines, including the trailing newline character (where present)\n */\nfunction splitLines(text) {\n  const hasTrailingNl = text.endsWith('\\n');\n  const result = text.split('\\n').map(line => line + '\\n');\n  if (hasTrailingNl) {\n    result.pop();\n  } else {\n    result.push(result.pop().slice(0, -1));\n  }\n  return result;\n}\n"],"names":["structuredPatch","oldFileName","newFileName","oldStr","newStr","oldHeader","newHeader","options","callback","context","newlineIsToken","Error","diffLinesResultToPatch","diff","patch","contextLines","lines","map","entry","push","value","hunks","oldRangeStart","newRangeStart","curRange","oldLine","newLine","i","length","current","splitLines","added","removed","prev","slice","contextSize","Math","min","hunk","oldStart","oldLines","newStart","newLines","endsWith","splice","formatPatch","Array","isArray","join","ret","apply","createTwoFilesPatch","_options","patchObj","text","hasTrailingNl","result","split","line","pop","fileName"],"mappings":"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"}