{"version":3,"file":"create.min.js","sources":["../../../src/jsdiff/patch/create.js"],"sourcesContent":["import {diffLines} from '../diff/line';\n\nexport function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  if (!options) {\n    options = {};\n  }\n  if (typeof options === 'function') {\n    options = {callback: options};\n  }\n  if (typeof options.context === 'undefined') {\n    options.context = 4;\n  }\n  if (options.newlineIsToken) {\n    throw new Error('newlineIsToken may not be used with patch-generation functions, only with diffing functions');\n  }\n\n  if (!options.callback) {\n    return diffLinesResultToPatch(diffLines(oldStr, newStr, options));\n  } else {\n    const {callback} = options;\n    diffLines(\n      oldStr,\n      newStr,\n      {\n        ...options,\n        callback: (diff) => {\n          const patch = diffLinesResultToPatch(diff);\n          callback(patch);\n        }\n      }\n    );\n  }\n\n  function diffLinesResultToPatch(diff) {\n    // STEP 1: Build up the patch with no \"\\ No newline at end of file\" lines and with the arrays\n    //         of lines containing trailing newline characters. We'll tidy up later...\n\n    if(!diff) {\n      return;\n    }\n\n    diff.push({value: '', lines: []}); // Append an empty value to make cleanup easier\n\n    function contextLines(lines) {\n      return lines.map(function(entry) { return ' ' + entry; });\n    }\n\n    let hunks = [];\n    let oldRangeStart = 0, newRangeStart = 0, curRange = [],\n        oldLine = 1, newLine = 1;\n    for (let i = 0; i < diff.length; i++) {\n      const current = diff[i],\n            lines = current.lines || splitLines(current.value);\n      current.lines = lines;\n\n      if (current.added || current.removed) {\n        // If we have previous context, start with that\n        if (!oldRangeStart) {\n          const prev = diff[i - 1];\n          oldRangeStart = oldLine;\n          newRangeStart = newLine;\n\n          if (prev) {\n            curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n            oldRangeStart -= curRange.length;\n            newRangeStart -= curRange.length;\n          }\n        }\n\n        // Output our changes\n        curRange.push(... lines.map(function(entry) {\n          return (current.added ? '+' : '-') + entry;\n        }));\n\n        // Track the updated file position\n        if (current.added) {\n          newLine += lines.length;\n        } else {\n          oldLine += lines.length;\n        }\n      } else {\n        // Identical context lines. Track line changes\n        if (oldRangeStart) {\n          // Close out any changes that have been output (or join overlapping)\n          if (lines.length <= options.context * 2 && i < diff.length - 2) {\n            // Overlapping\n            curRange.push(... contextLines(lines));\n          } else {\n            // end the range and output\n            let contextSize = Math.min(lines.length, options.context);\n            curRange.push(... contextLines(lines.slice(0, contextSize)));\n\n            let hunk = {\n              oldStart: oldRangeStart,\n              oldLines: (oldLine - oldRangeStart + contextSize),\n              newStart: newRangeStart,\n              newLines: (newLine - newRangeStart + contextSize),\n              lines: curRange\n            };\n            hunks.push(hunk);\n\n            oldRangeStart = 0;\n            newRangeStart = 0;\n            curRange = [];\n          }\n        }\n        oldLine += lines.length;\n        newLine += lines.length;\n      }\n    }\n\n    // Step 2: eliminate the trailing `\\n` from each line of each hunk, and, where needed, add\n    //         \"\\ No newline at end of file\".\n    for (const hunk of hunks) {\n      for (let i = 0; i < hunk.lines.length; i++) {\n        if (hunk.lines[i].endsWith('\\n')) {\n          hunk.lines[i] = hunk.lines[i].slice(0, -1);\n        } else {\n          hunk.lines.splice(i + 1, 0, '\\\\ No newline at end of file');\n          i++; // Skip the line we just added, then continue iterating\n        }\n      }\n    }\n\n    return {\n      oldFileName: oldFileName, newFileName: newFileName,\n      oldHeader: oldHeader, newHeader: newHeader,\n      hunks: hunks\n    };\n  }\n}\n\nexport function formatPatch(diff) {\n  if (Array.isArray(diff)) {\n    return diff.map(formatPatch).join('\\n');\n  }\n\n  const ret = [];\n  if (diff.oldFileName == diff.newFileName) {\n    ret.push('Index: ' + diff.oldFileName);\n  }\n  ret.push('===================================================================');\n  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n  for (let i = 0; i < diff.hunks.length; i++) {\n    const hunk = diff.hunks[i];\n    // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n    if (hunk.oldLines === 0) {\n      hunk.oldStart -= 1;\n    }\n    if (hunk.newLines === 0) {\n      hunk.newStart -= 1;\n    }\n    ret.push(\n      '@@ -' + hunk.oldStart + ',' + hunk.oldLines\n      + ' +' + hunk.newStart + ',' + hunk.newLines\n      + ' @@'\n    );\n    ret.push.apply(ret, hunk.lines);\n  }\n\n  return ret.join('\\n') + '\\n';\n}\n\nexport function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  if (typeof options === 'function') {\n    options = {callback: options};\n  }\n\n  if (!options?.callback) {\n    const patchObj = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);\n    if (!patchObj) {\n      return;\n    }\n    return formatPatch(patchObj);\n  } else {\n    const {callback} = options;\n    structuredPatch(\n      oldFileName,\n      newFileName,\n      oldStr,\n      newStr,\n      oldHeader,\n      newHeader,\n      {\n        ...options,\n        callback: patchObj => {\n          if (!patchObj) {\n            callback();\n          } else {\n            callback(formatPatch(patchObj));\n          }\n        }\n      }\n    );\n  }\n}\n\nexport function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}\n\n/**\n * Split `text` into an array of lines, including the trailing newline character (where present)\n */\nfunction splitLines(text) {\n  const hasTrailingNl = text.endsWith('\\n');\n  const result = text.split('\\n').map(line => line + '\\n');\n  if (hasTrailingNl) {\n    result.pop();\n  } else {\n    result.push(result.pop().slice(0, -1));\n  }\n  return result;\n}\n"],"names":["structuredPatch","oldFileName","newFileName","oldStr","newStr","oldHeader","newHeader","options","callback","context","newlineIsToken","Error","diffLinesResultToPatch","diffLines","diff","patch","contextLines","lines","map","entry","push","value","hunks","oldRangeStart","newRangeStart","curRange","oldLine","newLine","i","length","current","splitLines","added","removed","prev","slice","contextSize","Math","min","hunk","oldStart","oldLines","newStart","newLines","endsWith","splice","formatPatch","Array","isArray","join","ret","apply","createTwoFilesPatch","patchObj","text","hasTrailingNl","result","split","line","pop","fileName"],"mappings":"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"}