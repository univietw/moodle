define("tiny_collaborative/jsdiff/patch/merge",["exports","./create","./parse","../util/array"],(function(_exports,_create,_parse,_array){function calcLineCount(hunk){const{oldLines:oldLines,newLines:newLines}=calcOldNewLineCount(hunk.lines);void 0!==oldLines?hunk.oldLines=oldLines:delete hunk.oldLines,void 0!==newLines?hunk.newLines=newLines:delete hunk.newLines}function loadPatch(param,base){if("string"==typeof param){if(/^@@/m.test(param)||/^Index:/m.test(param))return(0,_parse.parsePatch)(param)[0];if(!base)throw new Error("Must provide a base reference or pass in a patch");return(0,_create.structuredPatch)(void 0,void 0,base,param)}return param}function fileNameChanged(patch){return patch.newFileName&&patch.newFileName!==patch.oldFileName}function selectField(index,mine,theirs){return mine===theirs?mine:(index.conflict=!0,{mine:mine,theirs:theirs})}function hunkBefore(test,check){return test.oldStart<check.oldStart&&test.oldStart+test.oldLines<check.oldStart}function cloneHunk(hunk,offset){return{oldStart:hunk.oldStart,oldLines:hunk.oldLines,newStart:hunk.newStart+offset,newLines:hunk.newLines,lines:hunk.lines}}function mergeLines(hunk,mineOffset,mineLines,theirOffset,theirLines){let mine={offset:mineOffset,lines:mineLines,index:0},their={offset:theirOffset,lines:theirLines,index:0};for(insertLeading(hunk,mine,their),insertLeading(hunk,their,mine);mine.index<mine.lines.length&&their.index<their.lines.length;){let mineCurrent=mine.lines[mine.index],theirCurrent=their.lines[their.index];"-"!==mineCurrent[0]&&"+"!==mineCurrent[0]||"-"!==theirCurrent[0]&&"+"!==theirCurrent[0]?"+"===mineCurrent[0]&&" "===theirCurrent[0]?hunk.lines.push(...collectChange(mine)):"+"===theirCurrent[0]&&" "===mineCurrent[0]?hunk.lines.push(...collectChange(their)):"-"===mineCurrent[0]&&" "===theirCurrent[0]?removal(hunk,mine,their):"-"===theirCurrent[0]&&" "===mineCurrent[0]?removal(hunk,their,mine,!0):mineCurrent===theirCurrent?(hunk.lines.push(mineCurrent),mine.index++,their.index++):conflict(hunk,collectChange(mine),collectChange(their)):mutualChange(hunk,mine,their)}insertTrailing(hunk,mine),insertTrailing(hunk,their),calcLineCount(hunk)}function mutualChange(hunk,mine,their){let myChanges=collectChange(mine),theirChanges=collectChange(their);if(allRemoves(myChanges)&&allRemoves(theirChanges)){if((0,_array.arrayStartsWith)(myChanges,theirChanges)&&skipRemoveSuperset(their,myChanges,myChanges.length-theirChanges.length))return void hunk.lines.push(...myChanges);if((0,_array.arrayStartsWith)(theirChanges,myChanges)&&skipRemoveSuperset(mine,theirChanges,theirChanges.length-myChanges.length))return void hunk.lines.push(...theirChanges)}else if((0,_array.arrayEqual)(myChanges,theirChanges))return void hunk.lines.push(...myChanges);conflict(hunk,myChanges,theirChanges)}function removal(hunk,mine,their,swap){let myChanges=collectChange(mine),theirChanges=function(state,matchChanges){let changes=[],merged=[],matchIndex=0,contextChanges=!1,conflicted=!1;for(;matchIndex<matchChanges.length&&state.index<state.lines.length;){let change=state.lines[state.index],match=matchChanges[matchIndex];if("+"===match[0])break;if(contextChanges=contextChanges||" "!==change[0],merged.push(match),matchIndex++,"+"===change[0])for(conflicted=!0;"+"===change[0];)changes.push(change),change=state.lines[++state.index];match.substr(1)===change.substr(1)?(changes.push(change),state.index++):conflicted=!0}"+"===(matchChanges[matchIndex]||"")[0]&&contextChanges&&(conflicted=!0);if(conflicted)return changes;for(;matchIndex<matchChanges.length;)merged.push(matchChanges[matchIndex++]);return{merged:merged,changes:changes}}(their,myChanges);theirChanges.merged?hunk.lines.push(...theirChanges.merged):conflict(hunk,swap?theirChanges:myChanges,swap?myChanges:theirChanges)}function conflict(hunk,mine,their){hunk.conflict=!0,hunk.lines.push({conflict:!0,mine:mine,theirs:their})}function insertLeading(hunk,insert,their){for(;insert.offset<their.offset&&insert.index<insert.lines.length;){let line=insert.lines[insert.index++];hunk.lines.push(line),insert.offset++}}function insertTrailing(hunk,insert){for(;insert.index<insert.lines.length;){let line=insert.lines[insert.index++];hunk.lines.push(line)}}function collectChange(state){let ret=[],operation=state.lines[state.index][0];for(;state.index<state.lines.length;){let line=state.lines[state.index];if("-"===operation&&"+"===line[0]&&(operation="+"),operation!==line[0])break;ret.push(line),state.index++}return ret}function allRemoves(changes){return changes.reduce((function(prev,change){return prev&&"-"===change[0]}),!0)}function skipRemoveSuperset(state,removeChanges,delta){for(let i=0;i<delta;i++){let changeContent=removeChanges[removeChanges.length-delta+i].substr(1);if(state.lines[state.index+i]!==" "+changeContent)return!1}return state.index+=delta,!0}function calcOldNewLineCount(lines){let oldLines=0,newLines=0;return lines.forEach((function(line){if("string"!=typeof line){let myCount=calcOldNewLineCount(line.mine),theirCount=calcOldNewLineCount(line.theirs);void 0!==oldLines&&(myCount.oldLines===theirCount.oldLines?oldLines+=myCount.oldLines:oldLines=void 0),void 0!==newLines&&(myCount.newLines===theirCount.newLines?newLines+=myCount.newLines:newLines=void 0)}else void 0===newLines||"+"!==line[0]&&" "!==line[0]||newLines++,void 0===oldLines||"-"!==line[0]&&" "!==line[0]||oldLines++})),{oldLines:oldLines,newLines:newLines}}Object.defineProperty(_exports,"__esModule",{value:!0}),_exports.calcLineCount=calcLineCount,_exports.merge=function(mine,theirs,base){mine=loadPatch(mine,base),theirs=loadPatch(theirs,base);let ret={};(mine.index||theirs.index)&&(ret.index=mine.index||theirs.index);(mine.newFileName||theirs.newFileName)&&(fileNameChanged(mine)?fileNameChanged(theirs)?(ret.oldFileName=selectField(ret,mine.oldFileName,theirs.oldFileName),ret.newFileName=selectField(ret,mine.newFileName,theirs.newFileName),ret.oldHeader=selectField(ret,mine.oldHeader,theirs.oldHeader),ret.newHeader=selectField(ret,mine.newHeader,theirs.newHeader)):(ret.oldFileName=mine.oldFileName,ret.newFileName=mine.newFileName,ret.oldHeader=mine.oldHeader,ret.newHeader=mine.newHeader):(ret.oldFileName=theirs.oldFileName||mine.oldFileName,ret.newFileName=theirs.newFileName||mine.newFileName,ret.oldHeader=theirs.oldHeader||mine.oldHeader,ret.newHeader=theirs.newHeader||mine.newHeader));ret.hunks=[];let mineIndex=0,theirsIndex=0,mineOffset=0,theirsOffset=0;for(;mineIndex<mine.hunks.length||theirsIndex<theirs.hunks.length;){let mineCurrent=mine.hunks[mineIndex]||{oldStart:1/0},theirsCurrent=theirs.hunks[theirsIndex]||{oldStart:1/0};if(hunkBefore(mineCurrent,theirsCurrent))ret.hunks.push(cloneHunk(mineCurrent,mineOffset)),mineIndex++,theirsOffset+=mineCurrent.newLines-mineCurrent.oldLines;else if(hunkBefore(theirsCurrent,mineCurrent))ret.hunks.push(cloneHunk(theirsCurrent,theirsOffset)),theirsIndex++,mineOffset+=theirsCurrent.newLines-theirsCurrent.oldLines;else{let mergedHunk={oldStart:Math.min(mineCurrent.oldStart,theirsCurrent.oldStart),oldLines:0,newStart:Math.min(mineCurrent.newStart+mineOffset,theirsCurrent.oldStart+theirsOffset),newLines:0,lines:[]};mergeLines(mergedHunk,mineCurrent.oldStart,mineCurrent.lines,theirsCurrent.oldStart,theirsCurrent.lines),theirsIndex++,mineIndex++,ret.hunks.push(mergedHunk)}}return ret}}));

//# sourceMappingURL=merge.min.js.map