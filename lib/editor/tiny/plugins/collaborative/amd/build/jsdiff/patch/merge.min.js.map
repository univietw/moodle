{"version":3,"file":"merge.min.js","sources":["../../../src/jsdiff/patch/merge.js"],"sourcesContent":["import {structuredPatch} from './create';\nimport {parsePatch} from './parse';\n\nimport {arrayEqual, arrayStartsWith} from '../util/array';\n\nexport function calcLineCount(hunk) {\n  const {oldLines, newLines} = calcOldNewLineCount(hunk.lines);\n\n  if (oldLines !== undefined) {\n    hunk.oldLines = oldLines;\n  } else {\n    delete hunk.oldLines;\n  }\n\n  if (newLines !== undefined) {\n    hunk.newLines = newLines;\n  } else {\n    delete hunk.newLines;\n  }\n}\n\nexport function merge(mine, theirs, base) {\n  mine = loadPatch(mine, base);\n  theirs = loadPatch(theirs, base);\n\n  let ret = {};\n\n  // For index we just let it pass through as it doesn't have any necessary meaning.\n  // Leaving sanity checks on this to the API consumer that may know more about the\n  // meaning in their own context.\n  if (mine.index || theirs.index) {\n    ret.index = mine.index || theirs.index;\n  }\n\n  if (mine.newFileName || theirs.newFileName) {\n    if (!fileNameChanged(mine)) {\n      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n      ret.newFileName = theirs.newFileName || mine.newFileName;\n      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n      ret.newHeader = theirs.newHeader || mine.newHeader;\n    } else if (!fileNameChanged(theirs)) {\n      // No header or no change in theirs, use ours\n      ret.oldFileName = mine.oldFileName;\n      ret.newFileName = mine.newFileName;\n      ret.oldHeader = mine.oldHeader;\n      ret.newHeader = mine.newHeader;\n    } else {\n      // Both changed... figure it out\n      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n    }\n  }\n\n  ret.hunks = [];\n\n  let mineIndex = 0,\n      theirsIndex = 0,\n      mineOffset = 0,\n      theirsOffset = 0;\n\n  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n    let mineCurrent = mine.hunks[mineIndex] || {oldStart: Infinity},\n        theirsCurrent = theirs.hunks[theirsIndex] || {oldStart: Infinity};\n\n    if (hunkBefore(mineCurrent, theirsCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n      mineIndex++;\n      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n      theirsIndex++;\n      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n    } else {\n      // Overlap, merge as best we can\n      let mergedHunk = {\n        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n        oldLines: 0,\n        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n        newLines: 0,\n        lines: []\n      };\n      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n      theirsIndex++;\n      mineIndex++;\n\n      ret.hunks.push(mergedHunk);\n    }\n  }\n\n  return ret;\n}\n\nfunction loadPatch(param, base) {\n  if (typeof param === 'string') {\n    if ((/^@@/m).test(param) || ((/^Index:/m).test(param))) {\n      return parsePatch(param)[0];\n    }\n\n    if (!base) {\n      throw new Error('Must provide a base reference or pass in a patch');\n    }\n    return structuredPatch(undefined, undefined, base, param);\n  }\n\n  return param;\n}\n\nfunction fileNameChanged(patch) {\n  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n}\n\nfunction selectField(index, mine, theirs) {\n  if (mine === theirs) {\n    return mine;\n  } else {\n    index.conflict = true;\n    return {mine, theirs};\n  }\n}\n\nfunction hunkBefore(test, check) {\n  return test.oldStart < check.oldStart\n    && (test.oldStart + test.oldLines) < check.oldStart;\n}\n\nfunction cloneHunk(hunk, offset) {\n  return {\n    oldStart: hunk.oldStart, oldLines: hunk.oldLines,\n    newStart: hunk.newStart + offset, newLines: hunk.newLines,\n    lines: hunk.lines\n  };\n}\n\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n  // This will generally result in a conflicted hunk, but there are cases where the context\n  // is the only overlap where we can successfully merge the content here.\n  let mine = {offset: mineOffset, lines: mineLines, index: 0},\n      their = {offset: theirOffset, lines: theirLines, index: 0};\n\n  // Handle any leading content\n  insertLeading(hunk, mine, their);\n  insertLeading(hunk, their, mine);\n\n  // Now in the overlap content. Scan through and select the best changes from each.\n  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n    let mineCurrent = mine.lines[mine.index],\n        theirCurrent = their.lines[their.index];\n\n    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+')\n        && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n      // Both modified ...\n      mutualChange(hunk, mine, their);\n    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n      // Mine inserted\n      hunk.lines.push(... collectChange(mine));\n    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n      // Theirs inserted\n      hunk.lines.push(... collectChange(their));\n    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n      // Mine removed or edited\n      removal(hunk, mine, their);\n    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n      // Their removed or edited\n      removal(hunk, their, mine, true);\n    } else if (mineCurrent === theirCurrent) {\n      // Context identity\n      hunk.lines.push(mineCurrent);\n      mine.index++;\n      their.index++;\n    } else {\n      // Context mismatch\n      conflict(hunk, collectChange(mine), collectChange(their));\n    }\n  }\n\n  // Now push anything that may be remaining\n  insertTrailing(hunk, mine);\n  insertTrailing(hunk, their);\n\n  calcLineCount(hunk);\n}\n\nfunction mutualChange(hunk, mine, their) {\n  let myChanges = collectChange(mine),\n      theirChanges = collectChange(their);\n\n  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n    // Special case for remove changes that are supersets of one another\n    if (arrayStartsWith(myChanges, theirChanges)\n        && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n      hunk.lines.push(... myChanges);\n      return;\n    } else if (arrayStartsWith(theirChanges, myChanges)\n        && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n      hunk.lines.push(... theirChanges);\n      return;\n    }\n  } else if (arrayEqual(myChanges, theirChanges)) {\n    hunk.lines.push(... myChanges);\n    return;\n  }\n\n  conflict(hunk, myChanges, theirChanges);\n}\n\nfunction removal(hunk, mine, their, swap) {\n  let myChanges = collectChange(mine),\n      theirChanges = collectContext(their, myChanges);\n  if (theirChanges.merged) {\n    hunk.lines.push(... theirChanges.merged);\n  } else {\n    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n  }\n}\n\nfunction conflict(hunk, mine, their) {\n  hunk.conflict = true;\n  hunk.lines.push({\n    conflict: true,\n    mine: mine,\n    theirs: their\n  });\n}\n\nfunction insertLeading(hunk, insert, their) {\n  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n    let line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n    insert.offset++;\n  }\n}\nfunction insertTrailing(hunk, insert) {\n  while (insert.index < insert.lines.length) {\n    let line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n  }\n}\n\nfunction collectChange(state) {\n  let ret = [],\n      operation = state.lines[state.index][0];\n  while (state.index < state.lines.length) {\n    let line = state.lines[state.index];\n\n    // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n    if (operation === '-' && line[0] === '+') {\n      operation = '+';\n    }\n\n    if (operation === line[0]) {\n      ret.push(line);\n      state.index++;\n    } else {\n      break;\n    }\n  }\n\n  return ret;\n}\nfunction collectContext(state, matchChanges) {\n  let changes = [],\n      merged = [],\n      matchIndex = 0,\n      contextChanges = false,\n      conflicted = false;\n  while (matchIndex < matchChanges.length\n        && state.index < state.lines.length) {\n    let change = state.lines[state.index],\n        match = matchChanges[matchIndex];\n\n    // Once we've hit our add, then we are done\n    if (match[0] === '+') {\n      break;\n    }\n\n    contextChanges = contextChanges || change[0] !== ' ';\n\n    merged.push(match);\n    matchIndex++;\n\n    // Consume any additions in the other block as a conflict to attempt\n    // to pull in the remaining context after this\n    if (change[0] === '+') {\n      conflicted = true;\n\n      while (change[0] === '+') {\n        changes.push(change);\n        change = state.lines[++state.index];\n      }\n    }\n\n    if (match.substr(1) === change.substr(1)) {\n      changes.push(change);\n      state.index++;\n    } else {\n      conflicted = true;\n    }\n  }\n\n  if ((matchChanges[matchIndex] || '')[0] === '+'\n      && contextChanges) {\n    conflicted = true;\n  }\n\n  if (conflicted) {\n    return changes;\n  }\n\n  while (matchIndex < matchChanges.length) {\n    merged.push(matchChanges[matchIndex++]);\n  }\n\n  return {\n    merged,\n    changes\n  };\n}\n\nfunction allRemoves(changes) {\n  return changes.reduce(function(prev, change) {\n    return prev && change[0] === '-';\n  }, true);\n}\nfunction skipRemoveSuperset(state, removeChanges, delta) {\n  for (let i = 0; i < delta; i++) {\n    let changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n    if (state.lines[state.index + i] !== ' ' + changeContent) {\n      return false;\n    }\n  }\n\n  state.index += delta;\n  return true;\n}\n\nfunction calcOldNewLineCount(lines) {\n  let oldLines = 0;\n  let newLines = 0;\n\n  lines.forEach(function(line) {\n    if (typeof line !== 'string') {\n      let myCount = calcOldNewLineCount(line.mine);\n      let theirCount = calcOldNewLineCount(line.theirs);\n\n      if (oldLines !== undefined) {\n        if (myCount.oldLines === theirCount.oldLines) {\n          oldLines += myCount.oldLines;\n        } else {\n          oldLines = undefined;\n        }\n      }\n\n      if (newLines !== undefined) {\n        if (myCount.newLines === theirCount.newLines) {\n          newLines += myCount.newLines;\n        } else {\n          newLines = undefined;\n        }\n      }\n    } else {\n      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n        newLines++;\n      }\n      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n        oldLines++;\n      }\n    }\n  });\n\n  return {oldLines, newLines};\n}\n"],"names":["calcLineCount","hunk","oldLines","newLines","calcOldNewLineCount","lines","undefined","loadPatch","param","base","test","Error","fileNameChanged","patch","newFileName","oldFileName","selectField","index","mine","theirs","conflict","hunkBefore","check","oldStart","cloneHunk","offset","newStart","mergeLines","mineOffset","mineLines","theirOffset","theirLines","their","insertLeading","length","mineCurrent","theirCurrent","push","collectChange","removal","mutualChange","insertTrailing","myChanges","theirChanges","allRemoves","skipRemoveSuperset","swap","state","matchChanges","changes","merged","matchIndex","contextChanges","conflicted","change","match","substr","collectContext","insert","line","ret","operation","reduce","prev","removeChanges","delta","i","changeContent","forEach","myCount","theirCount","oldHeader","newHeader","hunks","mineIndex","theirsIndex","theirsOffset","Infinity","theirsCurrent","mergedHunk","Math","min"],"mappings":"mJAKgBA,cAAcC,YACtBC,SAACA,SAADC,SAAWA,UAAYC,oBAAoBH,KAAKI,YAErCC,IAAbJ,SACFD,KAAKC,SAAWA,gBAETD,KAAKC,cAGGI,IAAbH,SACFF,KAAKE,SAAWA,gBAETF,KAAKE,kBAgFPI,UAAUC,MAAOC,SACH,iBAAVD,MAAoB,IACxB,OAAQE,KAAKF,QAAY,WAAYE,KAAKF,cACtC,qBAAWA,OAAO,OAGtBC,WACG,IAAIE,MAAM,2DAEX,gCAAgBL,OAAWA,EAAWG,KAAMD,cAG9CA,eAGAI,gBAAgBC,cAChBA,MAAMC,aAAeD,MAAMC,cAAgBD,MAAME,qBAGjDC,YAAYC,MAAOC,KAAMC,eAC5BD,OAASC,OACJD,MAEPD,MAAMG,UAAW,EACV,CAACF,KAAAA,KAAMC,OAAAA,kBAITE,WAAWX,KAAMY,cACjBZ,KAAKa,SAAWD,MAAMC,UACvBb,KAAKa,SAAWb,KAAKR,SAAYoB,MAAMC,kBAGtCC,UAAUvB,KAAMwB,cAChB,CACLF,SAAUtB,KAAKsB,SAAUrB,SAAUD,KAAKC,SACxCwB,SAAUzB,KAAKyB,SAAWD,OAAQtB,SAAUF,KAAKE,SACjDE,MAAOJ,KAAKI,gBAIPsB,WAAW1B,KAAM2B,WAAYC,UAAWC,YAAaC,gBAGxDb,KAAO,CAACO,OAAQG,WAAYvB,MAAOwB,UAAWZ,MAAO,GACrDe,MAAQ,CAACP,OAAQK,YAAazB,MAAO0B,WAAYd,MAAO,OAG5DgB,cAAchC,KAAMiB,KAAMc,OAC1BC,cAAchC,KAAM+B,MAAOd,MAGpBA,KAAKD,MAAQC,KAAKb,MAAM6B,QAAUF,MAAMf,MAAQe,MAAM3B,MAAM6B,QAAQ,KACrEC,YAAcjB,KAAKb,MAAMa,KAAKD,OAC9BmB,aAAeJ,MAAM3B,MAAM2B,MAAMf,OAEb,MAAnBkB,YAAY,IAAiC,MAAnBA,YAAY,IACf,MAApBC,aAAa,IAAkC,MAApBA,aAAa,GAGlB,MAAnBD,YAAY,IAAkC,MAApBC,aAAa,GAEhDnC,KAAKI,MAAMgC,QAASC,cAAcpB,OACL,MAApBkB,aAAa,IAAiC,MAAnBD,YAAY,GAEhDlC,KAAKI,MAAMgC,QAASC,cAAcN,QACN,MAAnBG,YAAY,IAAkC,MAApBC,aAAa,GAEhDG,QAAQtC,KAAMiB,KAAMc,OACS,MAApBI,aAAa,IAAiC,MAAnBD,YAAY,GAEhDI,QAAQtC,KAAM+B,MAAOd,MAAM,GAClBiB,cAAgBC,cAEzBnC,KAAKI,MAAMgC,KAAKF,aAChBjB,KAAKD,QACLe,MAAMf,SAGNG,SAASnB,KAAMqC,cAAcpB,MAAOoB,cAAcN,QApBlDQ,aAAavC,KAAMiB,KAAMc,OAyB7BS,eAAexC,KAAMiB,MACrBuB,eAAexC,KAAM+B,OAErBhC,cAAcC,eAGPuC,aAAavC,KAAMiB,KAAMc,WAC5BU,UAAYJ,cAAcpB,MAC1ByB,aAAeL,cAAcN,UAE7BY,WAAWF,YAAcE,WAAWD,cAAe,KAEjD,0BAAgBD,UAAWC,eACxBE,mBAAmBb,MAAOU,UAAWA,UAAUR,OAASS,aAAaT,oBAC1EjC,KAAKI,MAAMgC,QAASK,WAEf,IAAI,0BAAgBC,aAAcD,YAClCG,mBAAmB3B,KAAMyB,aAAcA,aAAaT,OAASQ,UAAUR,oBAC5EjC,KAAKI,MAAMgC,QAASM,mBAGjB,IAAI,qBAAWD,UAAWC,0BAC/B1C,KAAKI,MAAMgC,QAASK,WAItBtB,SAASnB,KAAMyC,UAAWC,uBAGnBJ,QAAQtC,KAAMiB,KAAMc,MAAOc,UAC9BJ,UAAYJ,cAAcpB,MAC1ByB,sBAoDkBI,MAAOC,kBACzBC,QAAU,GACVC,OAAS,GACTC,WAAa,EACbC,gBAAiB,EACjBC,YAAa,OACVF,WAAaH,aAAad,QACxBa,MAAM9B,MAAQ8B,MAAM1C,MAAM6B,QAAQ,KACrCoB,OAASP,MAAM1C,MAAM0C,MAAM9B,OAC3BsC,MAAQP,aAAaG,eAGR,MAAbI,MAAM,YAIVH,eAAiBA,gBAAgC,MAAdE,OAAO,GAE1CJ,OAAOb,KAAKkB,OACZJ,aAIkB,MAAdG,OAAO,OACTD,YAAa,EAEQ,MAAdC,OAAO,IACZL,QAAQZ,KAAKiB,QACbA,OAASP,MAAM1C,QAAQ0C,MAAM9B,OAI7BsC,MAAMC,OAAO,KAAOF,OAAOE,OAAO,IACpCP,QAAQZ,KAAKiB,QACbP,MAAM9B,SAENoC,YAAa,EAI2B,OAAvCL,aAAaG,aAAe,IAAI,IAC9BC,iBACLC,YAAa,MAGXA,kBACKJ,aAGFE,WAAaH,aAAad,QAC/BgB,OAAOb,KAAKW,aAAaG,qBAGpB,CACLD,OAAAA,OACAD,QAAAA,SA3GiBQ,CAAezB,MAAOU,WACrCC,aAAaO,OACfjD,KAAKI,MAAMgC,QAASM,aAAaO,QAEjC9B,SAASnB,KAAM6C,KAAOH,aAAeD,UAAWI,KAAOJ,UAAYC,uBAI9DvB,SAASnB,KAAMiB,KAAMc,OAC5B/B,KAAKmB,UAAW,EAChBnB,KAAKI,MAAMgC,KAAK,CACdjB,UAAU,EACVF,KAAMA,KACNC,OAAQa,iBAIHC,cAAchC,KAAMyD,OAAQ1B,YAC5B0B,OAAOjC,OAASO,MAAMP,QAAUiC,OAAOzC,MAAQyC,OAAOrD,MAAM6B,QAAQ,KACrEyB,KAAOD,OAAOrD,MAAMqD,OAAOzC,SAC/BhB,KAAKI,MAAMgC,KAAKsB,MAChBD,OAAOjC,mBAGFgB,eAAexC,KAAMyD,aACrBA,OAAOzC,MAAQyC,OAAOrD,MAAM6B,QAAQ,KACrCyB,KAAOD,OAAOrD,MAAMqD,OAAOzC,SAC/BhB,KAAKI,MAAMgC,KAAKsB,gBAIXrB,cAAcS,WACjBa,IAAM,GACNC,UAAYd,MAAM1C,MAAM0C,MAAM9B,OAAO,QAClC8B,MAAM9B,MAAQ8B,MAAM1C,MAAM6B,QAAQ,KACnCyB,KAAOZ,MAAM1C,MAAM0C,MAAM9B,UAGX,MAAd4C,WAAiC,MAAZF,KAAK,KAC5BE,UAAY,KAGVA,YAAcF,KAAK,SACrBC,IAAIvB,KAAKsB,MACTZ,MAAM9B,eAMH2C,aA6DAhB,WAAWK,gBACXA,QAAQa,QAAO,SAASC,KAAMT,eAC5BS,MAAsB,MAAdT,OAAO,MACrB,YAEIT,mBAAmBE,MAAOiB,cAAeC,WAC3C,IAAIC,EAAI,EAAGA,EAAID,MAAOC,IAAK,KAC1BC,cAAgBH,cAAcA,cAAc9B,OAAS+B,MAAQC,GAAGV,OAAO,MACvET,MAAM1C,MAAM0C,MAAM9B,MAAQiD,KAAO,IAAMC,qBAClC,SAIXpB,MAAM9B,OAASgD,OACR,WAGA7D,oBAAoBC,WACvBH,SAAW,EACXC,SAAW,SAEfE,MAAM+D,SAAQ,SAAST,SACD,iBAATA,KAAmB,KACxBU,QAAUjE,oBAAoBuD,KAAKzC,MACnCoD,WAAalE,oBAAoBuD,KAAKxC,aAEzBb,IAAbJ,WACEmE,QAAQnE,WAAaoE,WAAWpE,SAClCA,UAAYmE,QAAQnE,SAEpBA,cAAWI,QAIEA,IAAbH,WACEkE,QAAQlE,WAAamE,WAAWnE,SAClCA,UAAYkE,QAAQlE,SAEpBA,cAAWG,aAIEA,IAAbH,UAAuC,MAAZwD,KAAK,IAA0B,MAAZA,KAAK,IACrDxD,gBAEeG,IAAbJ,UAAuC,MAAZyD,KAAK,IAA0B,MAAZA,KAAK,IACrDzD,cAKC,CAACA,SAAAA,SAAUC,SAAAA,+HAjWEe,KAAMC,OAAQV,MAClCS,KAAOX,UAAUW,KAAMT,MACvBU,OAASZ,UAAUY,OAAQV,UAEvBmD,IAAM,IAKN1C,KAAKD,OAASE,OAAOF,SACvB2C,IAAI3C,MAAQC,KAAKD,OAASE,OAAOF,QAG/BC,KAAKJ,aAAeK,OAAOL,eACxBF,gBAAgBM,MAMTN,gBAAgBO,SAQ1ByC,IAAI7C,YAAcC,YAAY4C,IAAK1C,KAAKH,YAAaI,OAAOJ,aAC5D6C,IAAI9C,YAAcE,YAAY4C,IAAK1C,KAAKJ,YAAaK,OAAOL,aAC5D8C,IAAIW,UAAYvD,YAAY4C,IAAK1C,KAAKqD,UAAWpD,OAAOoD,WACxDX,IAAIY,UAAYxD,YAAY4C,IAAK1C,KAAKsD,UAAWrD,OAAOqD,aATxDZ,IAAI7C,YAAcG,KAAKH,YACvB6C,IAAI9C,YAAcI,KAAKJ,YACvB8C,IAAIW,UAAYrD,KAAKqD,UACrBX,IAAIY,UAAYtD,KAAKsD,YATrBZ,IAAI7C,YAAcI,OAAOJ,aAAeG,KAAKH,YAC7C6C,IAAI9C,YAAcK,OAAOL,aAAeI,KAAKJ,YAC7C8C,IAAIW,UAAYpD,OAAOoD,WAAarD,KAAKqD,UACzCX,IAAIY,UAAYrD,OAAOqD,WAAatD,KAAKsD,YAgB7CZ,IAAIa,MAAQ,OAERC,UAAY,EACZC,YAAc,EACd/C,WAAa,EACbgD,aAAe,OAEZF,UAAYxD,KAAKuD,MAAMvC,QAAUyC,YAAcxD,OAAOsD,MAAMvC,QAAQ,KACrEC,YAAcjB,KAAKuD,MAAMC,YAAc,CAACnD,SAAUsD,EAAAA,GAClDC,cAAgB3D,OAAOsD,MAAME,cAAgB,CAACpD,SAAUsD,EAAAA,MAExDxD,WAAWc,YAAa2C,eAE1BlB,IAAIa,MAAMpC,KAAKb,UAAUW,YAAaP,aACtC8C,YACAE,cAAgBzC,YAAYhC,SAAWgC,YAAYjC,cAC9C,GAAImB,WAAWyD,cAAe3C,aAEnCyB,IAAIa,MAAMpC,KAAKb,UAAUsD,cAAeF,eACxCD,cACA/C,YAAckD,cAAc3E,SAAW2E,cAAc5E,aAChD,KAED6E,WAAa,CACfxD,SAAUyD,KAAKC,IAAI9C,YAAYZ,SAAUuD,cAAcvD,UACvDrB,SAAU,EACVwB,SAAUsD,KAAKC,IAAI9C,YAAYT,SAAWE,WAAYkD,cAAcvD,SAAWqD,cAC/EzE,SAAU,EACVE,MAAO,IAETsB,WAAWoD,WAAY5C,YAAYZ,SAAUY,YAAY9B,MAAOyE,cAAcvD,SAAUuD,cAAczE,OACtGsE,cACAD,YAEAd,IAAIa,MAAMpC,KAAK0C,oBAIZnB"}