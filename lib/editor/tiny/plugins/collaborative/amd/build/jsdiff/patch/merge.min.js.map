{"version":3,"file":"merge.min.js","sources":["../../../src/jsdiff/patch/merge.js"],"sourcesContent":["import {structuredPatch} from './create';\nimport {parsePatch} from './parse';\n\nimport {arrayEqual, arrayStartsWith} from '../util/array';\n\nexport function calcLineCount(hunk) {\n  const {oldLines, newLines} = calcOldNewLineCount(hunk.lines);\n\n  if (oldLines !== undefined) {\n    hunk.oldLines = oldLines;\n  } else {\n    delete hunk.oldLines;\n  }\n\n  if (newLines !== undefined) {\n    hunk.newLines = newLines;\n  } else {\n    delete hunk.newLines;\n  }\n}\n\nexport function merge(mine, theirs, base) {\n  mine = loadPatch(mine, base);\n  theirs = loadPatch(theirs, base);\n\n  let ret = {};\n\n  // For index we just let it pass through as it doesn't have any necessary meaning.\n  // Leaving sanity checks on this to the API consumer that may know more about the\n  // meaning in their own context.\n  if (mine.index || theirs.index) {\n    ret.index = mine.index || theirs.index;\n  }\n\n  if (mine.newFileName || theirs.newFileName) {\n    if (!fileNameChanged(mine)) {\n      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n      ret.newFileName = theirs.newFileName || mine.newFileName;\n      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n      ret.newHeader = theirs.newHeader || mine.newHeader;\n    } else if (!fileNameChanged(theirs)) {\n      // No header or no change in theirs, use ours\n      ret.oldFileName = mine.oldFileName;\n      ret.newFileName = mine.newFileName;\n      ret.oldHeader = mine.oldHeader;\n      ret.newHeader = mine.newHeader;\n    } else {\n      // Both changed... figure it out\n      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n    }\n  }\n\n  ret.hunks = [];\n\n  let mineIndex = 0,\n      theirsIndex = 0,\n      mineOffset = 0,\n      theirsOffset = 0;\n\n  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n    let mineCurrent = mine.hunks[mineIndex] || {oldStart: Infinity},\n        theirsCurrent = theirs.hunks[theirsIndex] || {oldStart: Infinity};\n\n    if (hunkBefore(mineCurrent, theirsCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n      mineIndex++;\n      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n      theirsIndex++;\n      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n    } else {\n      // Overlap, merge as best we can\n      let mergedHunk = {\n        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n        oldLines: 0,\n        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n        newLines: 0,\n        lines: []\n      };\n      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n      theirsIndex++;\n      mineIndex++;\n\n      ret.hunks.push(mergedHunk);\n    }\n  }\n\n  return ret;\n}\n\nfunction loadPatch(param, base) {\n  if (typeof param === 'string') {\n    if ((/^@@/m).test(param) || ((/^Index:/m).test(param))) {\n      return parsePatch(param)[0];\n    }\n\n    if (!base) {\n      throw new Error('Must provide a base reference or pass in a patch');\n    }\n    return structuredPatch(undefined, undefined, base, param);\n  }\n\n  return param;\n}\n\nfunction fileNameChanged(patch) {\n  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n}\n\nfunction selectField(index, mine, theirs) {\n  if (mine === theirs) {\n    return mine;\n  } else {\n    index.conflict = true;\n    return {mine, theirs};\n  }\n}\n\nfunction hunkBefore(test, check) {\n  return test.oldStart < check.oldStart\n    && (test.oldStart + test.oldLines) < check.oldStart;\n}\n\nfunction cloneHunk(hunk, offset) {\n  return {\n    oldStart: hunk.oldStart, oldLines: hunk.oldLines,\n    newStart: hunk.newStart + offset, newLines: hunk.newLines,\n    lines: hunk.lines\n  };\n}\n\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n  // This will generally result in a conflicted hunk, but there are cases where the context\n  // is the only overlap where we can successfully merge the content here.\n  let mine = {offset: mineOffset, lines: mineLines, index: 0},\n      their = {offset: theirOffset, lines: theirLines, index: 0};\n\n  // Handle any leading content\n  insertLeading(hunk, mine, their);\n  insertLeading(hunk, their, mine);\n\n  // Now in the overlap content. Scan through and select the best changes from each.\n  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n    let mineCurrent = mine.lines[mine.index],\n        theirCurrent = their.lines[their.index];\n\n    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+')\n        && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n      // Both modified ...\n      mutualChange(hunk, mine, their);\n    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n      // Mine inserted\n      hunk.lines.push(... collectChange(mine));\n    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n      // Theirs inserted\n      hunk.lines.push(... collectChange(their));\n    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n      // Mine removed or edited\n      removal(hunk, mine, their);\n    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n      // Their removed or edited\n      removal(hunk, their, mine, true);\n    } else if (mineCurrent === theirCurrent) {\n      // Context identity\n      hunk.lines.push(mineCurrent);\n      mine.index++;\n      their.index++;\n    } else {\n      // Context mismatch\n      conflict(hunk, collectChange(mine), collectChange(their));\n    }\n  }\n\n  // Now push anything that may be remaining\n  insertTrailing(hunk, mine);\n  insertTrailing(hunk, their);\n\n  calcLineCount(hunk);\n}\n\nfunction mutualChange(hunk, mine, their) {\n  let myChanges = collectChange(mine),\n      theirChanges = collectChange(their);\n\n  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n    // Special case for remove changes that are supersets of one another\n    if (arrayStartsWith(myChanges, theirChanges)\n        && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n      hunk.lines.push(... myChanges);\n      return;\n    } else if (arrayStartsWith(theirChanges, myChanges)\n        && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n      hunk.lines.push(... theirChanges);\n      return;\n    }\n  } else if (arrayEqual(myChanges, theirChanges)) {\n    hunk.lines.push(... myChanges);\n    return;\n  }\n\n  conflict(hunk, myChanges, theirChanges);\n}\n\nfunction removal(hunk, mine, their, swap) {\n  let myChanges = collectChange(mine),\n      theirChanges = collectContext(their, myChanges);\n  if (theirChanges.merged) {\n    hunk.lines.push(... theirChanges.merged);\n  } else {\n    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n  }\n}\n\nfunction conflict(hunk, mine, their) {\n  hunk.conflict = true;\n  hunk.lines.push({\n    conflict: true,\n    mine: mine,\n    theirs: their\n  });\n}\n\nfunction insertLeading(hunk, insert, their) {\n  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n    let line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n    insert.offset++;\n  }\n}\nfunction insertTrailing(hunk, insert) {\n  while (insert.index < insert.lines.length) {\n    let line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n  }\n}\n\nfunction collectChange(state) {\n  let ret = [],\n      operation = state.lines[state.index][0];\n  while (state.index < state.lines.length) {\n    let line = state.lines[state.index];\n\n    // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n    if (operation === '-' && line[0] === '+') {\n      operation = '+';\n    }\n\n    if (operation === line[0]) {\n      ret.push(line);\n      state.index++;\n    } else {\n      break;\n    }\n  }\n\n  return ret;\n}\nfunction collectContext(state, matchChanges) {\n  let changes = [],\n      merged = [],\n      matchIndex = 0,\n      contextChanges = false,\n      conflicted = false;\n  while (matchIndex < matchChanges.length\n        && state.index < state.lines.length) {\n    let change = state.lines[state.index],\n        match = matchChanges[matchIndex];\n\n    // Once we've hit our add, then we are done\n    if (match[0] === '+') {\n      break;\n    }\n\n    contextChanges = contextChanges || change[0] !== ' ';\n\n    merged.push(match);\n    matchIndex++;\n\n    // Consume any additions in the other block as a conflict to attempt\n    // to pull in the remaining context after this\n    if (change[0] === '+') {\n      conflicted = true;\n\n      while (change[0] === '+') {\n        changes.push(change);\n        change = state.lines[++state.index];\n      }\n    }\n\n    if (match.substr(1) === change.substr(1)) {\n      changes.push(change);\n      state.index++;\n    } else {\n      conflicted = true;\n    }\n  }\n\n  if ((matchChanges[matchIndex] || '')[0] === '+'\n      && contextChanges) {\n    conflicted = true;\n  }\n\n  if (conflicted) {\n    return changes;\n  }\n\n  while (matchIndex < matchChanges.length) {\n    merged.push(matchChanges[matchIndex++]);\n  }\n\n  return {\n    merged,\n    changes\n  };\n}\n\nfunction allRemoves(changes) {\n  return changes.reduce(function(prev, change) {\n    return prev && change[0] === '-';\n  }, true);\n}\nfunction skipRemoveSuperset(state, removeChanges, delta) {\n  for (let i = 0; i < delta; i++) {\n    let changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n    if (state.lines[state.index + i] !== ' ' + changeContent) {\n      return false;\n    }\n  }\n\n  state.index += delta;\n  return true;\n}\n\nfunction calcOldNewLineCount(lines) {\n  let oldLines = 0;\n  let newLines = 0;\n\n  lines.forEach(function(line) {\n    if (typeof line !== 'string') {\n      let myCount = calcOldNewLineCount(line.mine);\n      let theirCount = calcOldNewLineCount(line.theirs);\n\n      if (oldLines !== undefined) {\n        if (myCount.oldLines === theirCount.oldLines) {\n          oldLines += myCount.oldLines;\n        } else {\n          oldLines = undefined;\n        }\n      }\n\n      if (newLines !== undefined) {\n        if (myCount.newLines === theirCount.newLines) {\n          newLines += myCount.newLines;\n        } else {\n          newLines = undefined;\n        }\n      }\n    } else {\n      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n        newLines++;\n      }\n      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n        oldLines++;\n      }\n    }\n  });\n\n  return {oldLines, newLines};\n}\n"],"names":["calcLineCount","hunk","oldLines","newLines","calcOldNewLineCount","lines","undefined","loadPatch","param","base","test","parsePatch","Error","structuredPatch","fileNameChanged","patch","newFileName","oldFileName","selectField","index","mine","theirs","conflict","hunkBefore","check","oldStart","cloneHunk","offset","newStart","mergeLines","mineOffset","mineLines","theirOffset","theirLines","their","insertLeading","length","mineCurrent","theirCurrent","push","collectChange","removal","mutualChange","insertTrailing","myChanges","theirChanges","allRemoves","arrayStartsWith","skipRemoveSuperset","arrayEqual","swap","state","matchChanges","changes","merged","matchIndex","contextChanges","conflicted","change","match","substr","collectContext","insert","line","ret","operation","reduce","prev","removeChanges","delta","i","changeContent","forEach","myCount","theirCount","oldHeader","newHeader","hunks","mineIndex","theirsIndex","theirsOffset","Infinity","theirsCurrent","mergedHunk","Math","min"],"mappings":"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"}