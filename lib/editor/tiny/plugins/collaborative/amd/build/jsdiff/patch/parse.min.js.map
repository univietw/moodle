{"version":3,"file":"parse.min.js","sources":["../../../src/jsdiff/patch/parse.js"],"sourcesContent":["export function parsePatch(uniDiff) {\n  let diffstr = uniDiff.split(/\\n/),\n      list = [],\n      i = 0;\n\n  function parseIndex() {\n    let index = {};\n    list.push(index);\n\n    // Parse diff metadata\n    while (i < diffstr.length) {\n      let line = diffstr[i];\n\n      // File header found, end parsing diff metadata\n      if ((/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/).test(line)) {\n        break;\n      }\n\n      // Diff index\n      let header = (/^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/).exec(line);\n      if (header) {\n        index.index = header[1];\n      }\n\n      i++;\n    }\n\n    // Parse file headers if they are defined. Unified diff requires them, but\n    // there's no technical issues to have an isolated hunk without file header\n    parseFileHeader(index);\n    parseFileHeader(index);\n\n    // Parse hunks\n    index.hunks = [];\n\n    while (i < diffstr.length) {\n      let line = diffstr[i];\n      if ((/^(Index:\\s|diff\\s|\\-\\-\\-\\s|\\+\\+\\+\\s|===================================================================)/).test(line)) {\n        break;\n      } else if ((/^@@/).test(line)) {\n        index.hunks.push(parseHunk());\n      } else if (line) {\n        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(line));\n      } else {\n        i++;\n      }\n    }\n  }\n\n  // Parses the --- and +++ headers, if none are found, no lines\n  // are consumed.\n  function parseFileHeader(index) {\n    const fileHeader = (/^(---|\\+\\+\\+)\\s+(.*)\\r?$/).exec(diffstr[i]);\n    if (fileHeader) {\n      let keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n      const data = fileHeader[2].split('\\t', 2);\n      let fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n      if ((/^\".*\"$/).test(fileName)) {\n        fileName = fileName.substr(1, fileName.length - 2);\n      }\n      index[keyPrefix + 'FileName'] = fileName;\n      index[keyPrefix + 'Header'] = (data[1] || '').trim();\n\n      i++;\n    }\n  }\n\n  // Parses a hunk\n  // This assumes that we are at the start of a hunk.\n  function parseHunk() {\n    let chunkHeaderIndex = i,\n        chunkHeaderLine = diffstr[i++],\n        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n\n    let hunk = {\n      oldStart: +chunkHeader[1],\n      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n      newStart: +chunkHeader[3],\n      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n      lines: []\n    };\n\n    // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n    if (hunk.oldLines === 0) {\n      hunk.oldStart += 1;\n    }\n    if (hunk.newLines === 0) {\n      hunk.newStart += 1;\n    }\n\n    let addCount = 0,\n        removeCount = 0;\n    for (\n      ;\n      i < diffstr.length && (removeCount < hunk.oldLines || addCount < hunk.newLines || diffstr[i]?.startsWith('\\\\'));\n      i++\n    ) {\n      let operation = (diffstr[i].length == 0 && i != (diffstr.length - 1)) ? ' ' : diffstr[i][0];\n      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n        hunk.lines.push(diffstr[i]);\n\n        if (operation === '+') {\n          addCount++;\n        } else if (operation === '-') {\n          removeCount++;\n        } else if (operation === ' ') {\n          addCount++;\n          removeCount++;\n        }\n      } else {\n        throw new Error(`Hunk at line ${chunkHeaderIndex + 1} contained invalid line ${diffstr[i]}`);\n      }\n    }\n\n    // Handle the empty block count case\n    if (!addCount && hunk.newLines === 1) {\n      hunk.newLines = 0;\n    }\n    if (!removeCount && hunk.oldLines === 1) {\n      hunk.oldLines = 0;\n    }\n\n    // Perform sanity checking\n    if (addCount !== hunk.newLines) {\n      throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n    }\n    if (removeCount !== hunk.oldLines) {\n      throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n    }\n\n    return hunk;\n  }\n\n  while (i < diffstr.length) {\n    parseIndex();\n  }\n\n  return list;\n}\n"],"names":["uniDiff","diffstr","split","list","i","parseIndex","index","push","length","line","test","header","exec","parseFileHeader","hunks","parseHunk","Error","JSON","stringify","fileHeader","keyPrefix","data","fileName","replace","substr","trim","chunkHeaderIndex","chunkHeader","hunk","oldStart","oldLines","newStart","newLines","lines","addCount","removeCount","_diffstr$i","startsWith","operation"],"mappings":"oKAA2BA,aACrBC,QAAUD,QAAQE,MAAM,MACxBC,KAAO,GACPC,EAAI,WAECC,iBACHC,MAAQ,OACZH,KAAKI,KAAKD,OAGHF,EAAIH,QAAQO,QAAQ,KACrBC,KAAOR,QAAQG,MAGd,wBAAyBM,KAAKD,gBAK/BE,OAAU,2CAA4CC,KAAKH,MAC3DE,SACFL,MAAMA,MAAQK,OAAO,IAGvBP,QAKFS,gBAAgBP,OAChBO,gBAAgBP,OAGhBA,MAAMQ,MAAQ,GAEPV,EAAIH,QAAQO,QAAQ,KACrBC,KAAOR,QAAQG,MACd,2GAA4GM,KAAKD,YAE/G,GAAK,MAAOC,KAAKD,MACtBH,MAAMQ,MAAMP,KAAKQ,iBACZ,CAAA,GAAIN,WACH,IAAIO,MAAM,iBAAmBZ,EAAI,GAAK,IAAMa,KAAKC,UAAUT,OAEjEL,eAOGS,gBAAgBP,aACjBa,WAAc,2BAA4BP,KAAKX,QAAQG,OACzDe,WAAY,KACVC,UAA8B,QAAlBD,WAAW,GAAe,MAAQ,YAC5CE,KAAOF,WAAW,GAAGjB,MAAM,KAAM,OACnCoB,SAAWD,KAAK,GAAGE,QAAQ,QAAS,MACnC,SAAUb,KAAKY,YAClBA,SAAWA,SAASE,OAAO,EAAGF,SAASd,OAAS,IAElDF,MAAMc,UAAY,YAAcE,SAChChB,MAAMc,UAAY,WAAaC,KAAK,IAAM,IAAII,OAE9CrB,cAMKW,gBACHW,iBAAmBtB,EAEnBuB,YADkB1B,QAAQG,KACIF,MAAM,8CAEpC0B,KAAO,CACTC,UAAWF,YAAY,GACvBG,cAAoC,IAAnBH,YAAY,GAAqB,GAAKA,YAAY,GACnEI,UAAWJ,YAAY,GACvBK,cAAoC,IAAnBL,YAAY,GAAqB,GAAKA,YAAY,GACnEM,MAAO,IAMa,IAAlBL,KAAKE,WACPF,KAAKC,UAAY,GAEG,IAAlBD,KAAKI,WACPJ,KAAKG,UAAY,OAGfG,SAAW,EACXC,YAAc,OAGhB/B,EAAIH,QAAQO,SAAW2B,YAAcP,KAAKE,UAAYI,SAAWN,KAAKI,6BAAY/B,QAAQG,0BAARgC,WAAYC,WAAW,OACzGjC,IACA,oBACIkC,UAAkC,GAArBrC,QAAQG,GAAGI,QAAeJ,GAAMH,QAAQO,OAAS,EAAM,IAAMP,QAAQG,GAAG,MACvE,MAAdkC,WAAmC,MAAdA,WAAmC,MAAdA,WAAmC,OAAdA,gBAY3D,IAAItB,6BAAsBU,iBAAmB,qCAA4BzB,QAAQG,KAXvFwB,KAAKK,MAAM1B,KAAKN,QAAQG,IAEN,MAAdkC,UACFJ,WACuB,MAAdI,UACTH,cACuB,MAAdG,YACTJ,WACAC,kBAQDD,UAA8B,IAAlBN,KAAKI,WACpBJ,KAAKI,SAAW,GAEbG,aAAiC,IAAlBP,KAAKE,WACvBF,KAAKE,SAAW,GAIdI,WAAaN,KAAKI,eACd,IAAIhB,MAAM,oDAAsDU,iBAAmB,OAEvFS,cAAgBP,KAAKE,eACjB,IAAId,MAAM,sDAAwDU,iBAAmB,WAGtFE,UAGFxB,EAAIH,QAAQO,QACjBH,oBAGKF"}