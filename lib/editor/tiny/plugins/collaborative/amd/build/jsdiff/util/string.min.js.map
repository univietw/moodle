{"version":3,"file":"string.min.js","sources":["../../../src/jsdiff/util/string.js"],"sourcesContent":["export function longestCommonPrefix(str1, str2) {\n  let i;\n  for (i = 0; i < str1.length && i < str2.length; i++) {\n    if (str1[i] != str2[i]) {\n      return str1.slice(0, i);\n    }\n  }\n  return str1.slice(0, i);\n}\n\nexport function longestCommonSuffix(str1, str2) {\n  let i;\n\n  // Unlike longestCommonPrefix, we need a special case to handle all scenarios\n  // where we return the empty string since str1.slice(-0) will return the\n  // entire string.\n  if (!str1 || !str2 || str1[str1.length - 1] != str2[str2.length - 1]) {\n    return '';\n  }\n\n  for (i = 0; i < str1.length && i < str2.length; i++) {\n    if (str1[str1.length - (i + 1)] != str2[str2.length - (i + 1)]) {\n      return str1.slice(-i);\n    }\n  }\n  return str1.slice(-i);\n}\n\nexport function replacePrefix(string, oldPrefix, newPrefix) {\n  if (string.slice(0, oldPrefix.length) != oldPrefix) {\n    throw Error(`string ${JSON.stringify(string)} doesn't start with prefix ${JSON.stringify(oldPrefix)}; this is a bug`);\n  }\n  return newPrefix + string.slice(oldPrefix.length);\n}\n\nexport function replaceSuffix(string, oldSuffix, newSuffix) {\n  if (!oldSuffix) {\n    return string + newSuffix;\n  }\n\n  if (string.slice(-oldSuffix.length) != oldSuffix) {\n    throw Error(`string ${JSON.stringify(string)} doesn't end with suffix ${JSON.stringify(oldSuffix)}; this is a bug`);\n  }\n  return string.slice(0, -oldSuffix.length) + newSuffix;\n}\n\nexport function removePrefix(string, oldPrefix) {\n  return replacePrefix(string, oldPrefix, '');\n}\n\nexport function removeSuffix(string, oldSuffix) {\n  return replaceSuffix(string, oldSuffix, '');\n}\n\nexport function maximumOverlap(string1, string2) {\n  return string2.slice(0, overlapCount(string1, string2));\n}\n\n// Nicked from https://stackoverflow.com/a/60422853/1709587\nfunction overlapCount(a, b) {\n  // Deal with cases where the strings differ in length\n  let startA = 0;\n  if (a.length > b.length) { startA = a.length - b.length; }\n  let endB = b.length;\n  if (a.length < b.length) { endB = a.length; }\n  // Create a back-reference for each index\n  //   that should be followed in case of a mismatch.\n  //   We only need B to make these references:\n  let map = Array(endB);\n  let k = 0; // Index that lags behind j\n  map[0] = 0;\n  for (let j = 1; j < endB; j++) {\n      if (b[j] == b[k]) {\n          map[j] = map[k]; // skip over the same character (optional optimisation)\n      } else {\n          map[j] = k;\n      }\n      while (k > 0 && b[j] != b[k]) { k = map[k]; }\n      if (b[j] == b[k]) { k++; }\n  }\n  // Phase 2: use these references while iterating over A\n  k = 0;\n  for (let i = startA; i < a.length; i++) {\n      while (k > 0 && a[i] != b[k]) { k = map[k]; }\n      if (a[i] == b[k]) { k++; }\n  }\n  return k;\n}\n\n\n/**\n * Returns true if the string consistently uses Windows line endings.\n */\nexport function hasOnlyWinLineEndings(string) {\n  return string.includes('\\r\\n') && !string.startsWith('\\n') && !string.match(/[^\\r]\\n/);\n}\n\n/**\n * Returns true if the string consistently uses Unix line endings.\n */\nexport function hasOnlyUnixLineEndings(string) {\n  return !string.includes('\\r\\n') && string.includes('\\n');\n}\n"],"names":["replacePrefix","string","oldPrefix","newPrefix","slice","length","Error","JSON","stringify","replaceSuffix","oldSuffix","newSuffix","includes","startsWith","match","str1","str2","i","string1","string2","a","b","startA","endB","map","Array","k","j","overlapCount"],"mappings":"wFA4BgBA,cAAcC,OAAQC,UAAWC,cAC3CF,OAAOG,MAAM,EAAGF,UAAUG,SAAWH,gBACjCI,uBAAgBC,KAAKC,UAAUP,8CAAqCM,KAAKC,UAAUN,sCAEpFC,UAAYF,OAAOG,MAAMF,UAAUG,iBAG5BI,cAAcR,OAAQS,UAAWC,eAC1CD,iBACIT,OAASU,aAGdV,OAAOG,OAAOM,UAAUL,SAAWK,gBAC/BJ,uBAAgBC,KAAKC,UAAUP,4CAAmCM,KAAKC,UAAUE,sCAElFT,OAAOG,MAAM,GAAIM,UAAUL,QAAUM,2GAyDPV,eAC7BA,OAAOW,SAAS,SAAWX,OAAOW,SAAS,+CARfX,eAC7BA,OAAOW,SAAS,UAAYX,OAAOY,WAAW,QAAUZ,OAAOa,MAAM,kDA9F1CC,KAAMC,UACpCC,MACCA,EAAI,EAAGA,EAAIF,KAAKV,QAAUY,EAAID,KAAKX,OAAQY,OAC1CF,KAAKE,IAAMD,KAAKC,UACXF,KAAKX,MAAM,EAAGa,UAGlBF,KAAKX,MAAM,EAAGa,0CAGaF,KAAMC,UACpCC,MAKCF,OAASC,MAAQD,KAAKA,KAAKV,OAAS,IAAMW,KAAKA,KAAKX,OAAS,SACzD,OAGJY,EAAI,EAAGA,EAAIF,KAAKV,QAAUY,EAAID,KAAKX,OAAQY,OAC1CF,KAAKA,KAAKV,QAAUY,EAAI,KAAOD,KAAKA,KAAKX,QAAUY,EAAI,WAClDF,KAAKX,OAAOa,UAGhBF,KAAKX,OAAOa,qCA6BUC,QAASC,gBAC/BA,QAAQf,MAAM,WAIDgB,EAAGC,OAEnBC,OAAS,EACTF,EAAEf,OAASgB,EAAEhB,SAAUiB,OAASF,EAAEf,OAASgB,EAAEhB,YAC7CkB,KAAOF,EAAEhB,OACTe,EAAEf,OAASgB,EAAEhB,SAAUkB,KAAOH,EAAEf,YAIhCmB,IAAMC,MAAMF,MACZG,EAAI,EACRF,IAAI,GAAK,MACJ,IAAIG,EAAI,EAAGA,EAAIJ,KAAMI,IAAK,KACvBN,EAAEM,IAAMN,EAAEK,GACVF,IAAIG,GAAKH,IAAIE,GAEbF,IAAIG,GAAKD,EAENA,EAAI,GAAKL,EAAEM,IAAMN,EAAEK,IAAMA,EAAIF,IAAIE,GACpCL,EAAEM,IAAMN,EAAEK,IAAMA,IAGxBA,EAAI,MACC,IAAIT,EAAIK,OAAQL,EAAIG,EAAEf,OAAQY,IAAK,MAC7BS,EAAI,GAAKN,EAAEH,IAAMI,EAAEK,IAAMA,EAAIF,IAAIE,GACpCN,EAAEH,IAAMI,EAAEK,IAAMA,WAEjBA,EA/BiBE,CAAaV,QAASC,0CATnBlB,OAAQC,kBAC5BF,cAAcC,OAAQC,UAAW,oCAGbD,OAAQS,kBAC5BD,cAAcR,OAAQS,UAAW"}