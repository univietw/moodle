{"version":3,"file":"string.min.js","sources":["../../../src/jsdiff/util/string.js"],"sourcesContent":["export function longestCommonPrefix(str1, str2) {\n  let i;\n  for (i = 0; i < str1.length && i < str2.length; i++) {\n    if (str1[i] != str2[i]) {\n      return str1.slice(0, i);\n    }\n  }\n  return str1.slice(0, i);\n}\n\nexport function longestCommonSuffix(str1, str2) {\n  let i;\n\n  // Unlike longestCommonPrefix, we need a special case to handle all scenarios\n  // where we return the empty string since str1.slice(-0) will return the\n  // entire string.\n  if (!str1 || !str2 || str1[str1.length - 1] != str2[str2.length - 1]) {\n    return '';\n  }\n\n  for (i = 0; i < str1.length && i < str2.length; i++) {\n    if (str1[str1.length - (i + 1)] != str2[str2.length - (i + 1)]) {\n      return str1.slice(-i);\n    }\n  }\n  return str1.slice(-i);\n}\n\nexport function replacePrefix(string, oldPrefix, newPrefix) {\n  if (string.slice(0, oldPrefix.length) != oldPrefix) {\n    throw Error(`string ${JSON.stringify(string)} doesn't start with prefix ${JSON.stringify(oldPrefix)}; this is a bug`);\n  }\n  return newPrefix + string.slice(oldPrefix.length);\n}\n\nexport function replaceSuffix(string, oldSuffix, newSuffix) {\n  if (!oldSuffix) {\n    return string + newSuffix;\n  }\n\n  if (string.slice(-oldSuffix.length) != oldSuffix) {\n    throw Error(`string ${JSON.stringify(string)} doesn't end with suffix ${JSON.stringify(oldSuffix)}; this is a bug`);\n  }\n  return string.slice(0, -oldSuffix.length) + newSuffix;\n}\n\nexport function removePrefix(string, oldPrefix) {\n  return replacePrefix(string, oldPrefix, '');\n}\n\nexport function removeSuffix(string, oldSuffix) {\n  return replaceSuffix(string, oldSuffix, '');\n}\n\nexport function maximumOverlap(string1, string2) {\n  return string2.slice(0, overlapCount(string1, string2));\n}\n\n// Nicked from https://stackoverflow.com/a/60422853/1709587\nfunction overlapCount(a, b) {\n  // Deal with cases where the strings differ in length\n  let startA = 0;\n  if (a.length > b.length) { startA = a.length - b.length; }\n  let endB = b.length;\n  if (a.length < b.length) { endB = a.length; }\n  // Create a back-reference for each index\n  //   that should be followed in case of a mismatch.\n  //   We only need B to make these references:\n  let map = Array(endB);\n  let k = 0; // Index that lags behind j\n  map[0] = 0;\n  for (let j = 1; j < endB; j++) {\n      if (b[j] == b[k]) {\n          map[j] = map[k]; // skip over the same character (optional optimisation)\n      } else {\n          map[j] = k;\n      }\n      while (k > 0 && b[j] != b[k]) { k = map[k]; }\n      if (b[j] == b[k]) { k++; }\n  }\n  // Phase 2: use these references while iterating over A\n  k = 0;\n  for (let i = startA; i < a.length; i++) {\n      while (k > 0 && a[i] != b[k]) { k = map[k]; }\n      if (a[i] == b[k]) { k++; }\n  }\n  return k;\n}\n\n\n/**\n * Returns true if the string consistently uses Windows line endings.\n */\nexport function hasOnlyWinLineEndings(string) {\n  return string.includes('\\r\\n') && !string.startsWith('\\n') && !string.match(/[^\\r]\\n/);\n}\n\n/**\n * Returns true if the string consistently uses Unix line endings.\n */\nexport function hasOnlyUnixLineEndings(string) {\n  return !string.includes('\\r\\n') && string.includes('\\n');\n}\n"],"names":["replacePrefix","string","oldPrefix","newPrefix","slice","length","Error","JSON","stringify","replaceSuffix","oldSuffix","newSuffix","includes","startsWith","match","str1","str2","i","string1","string2","a","b","startA","endB","map","Array","k","j","overlapCount"],"mappings":"+EA4BO,SAASA,cAAcC,OAAQC,UAAWC,WAC/C,GAAIF,OAAOG,MAAM,EAAGF,UAAUG,SAAWH,UACvC,MAAMI,MAAM,UAAUC,KAAKC,UAAUP,qCAAqCM,KAAKC,UAAUN,6BAE3F,OAAOC,UAAYF,OAAOG,MAAMF,UAAUG,OAC5C,CAEO,SAASI,cAAcR,OAAQS,UAAWC,WAC/C,IAAKD,UACH,OAAOT,OAASU,UAGlB,GAAIV,OAAOG,OAAOM,UAAUL,SAAWK,UACrC,MAAMJ,MAAM,UAAUC,KAAKC,UAAUP,mCAAmCM,KAAKC,UAAUE,6BAEzF,OAAOT,OAAOG,MAAM,GAAIM,UAAUL,QAAUM,SAC9C,yFAwDO,SAAgCV,QACrC,OAAQA,OAAOW,SAAS,SAAWX,OAAOW,SAAS,KACrD,iCATO,SAA+BX,QACpC,OAAOA,OAAOW,SAAS,UAAYX,OAAOY,WAAW,QAAUZ,OAAOa,MAAM,UAC9E,+BA/FO,SAA6BC,KAAMC,MACxC,IAAIC,EACJ,IAAKA,EAAI,EAAGA,EAAIF,KAAKV,QAAUY,EAAID,KAAKX,OAAQY,IAC9C,GAAIF,KAAKE,IAAMD,KAAKC,GAClB,OAAOF,KAAKX,MAAM,EAAGa,GAGzB,OAAOF,KAAKX,MAAM,EAAGa,EACvB,+BAEO,SAA6BF,KAAMC,MACxC,IAAIC,EAKJ,IAAKF,OAASC,MAAQD,KAAKA,KAAKV,OAAS,IAAMW,KAAKA,KAAKX,OAAS,GAChE,MAAO,GAGT,IAAKY,EAAI,EAAGA,EAAIF,KAAKV,QAAUY,EAAID,KAAKX,OAAQY,IAC9C,GAAIF,KAAKA,KAAKV,QAAUY,EAAI,KAAOD,KAAKA,KAAKX,QAAUY,EAAI,IACzD,OAAOF,KAAKX,OAAOa,GAGvB,OAAOF,KAAKX,OAAOa,EACrB,0BA4BO,SAAwBC,QAASC,SACtC,OAAOA,QAAQf,MAAM,EAIvB,SAAsBgB,EAAGC,GAEvB,IAAIC,OAAS,EACTF,EAAEf,OAASgB,EAAEhB,SAAUiB,OAASF,EAAEf,OAASgB,EAAEhB,QACjD,IAAIkB,KAAOF,EAAEhB,OACTe,EAAEf,OAASgB,EAAEhB,SAAUkB,KAAOH,EAAEf,QAIpC,IAAImB,IAAMC,MAAMF,MACZG,EAAI,EACRF,IAAI,GAAK,EACT,IAAK,IAAIG,EAAI,EAAGA,EAAIJ,KAAMI,IAAK,CAM3B,IALIN,EAAEM,IAAMN,EAAEK,GACVF,IAAIG,GAAKH,IAAIE,GAEbF,IAAIG,GAAKD,EAENA,EAAI,GAAKL,EAAEM,IAAMN,EAAEK,IAAMA,EAAIF,IAAIE,GACpCL,EAAEM,IAAMN,EAAEK,IAAMA,GACxB,CAEAA,EAAI,EACJ,IAAK,IAAIT,EAAIK,OAAQL,EAAIG,EAAEf,OAAQY,IAAK,CACpC,KAAOS,EAAI,GAAKN,EAAEH,IAAMI,EAAEK,IAAMA,EAAIF,IAAIE,GACpCN,EAAEH,IAAMI,EAAEK,IAAMA,GACxB,CACA,OAAOA,CACT,CAhC0BE,CAAaV,QAASC,SAChD,wBAVO,SAAsBlB,OAAQC,WACnC,OAAOF,cAAcC,OAAQC,UAAW,GAC1C,wBAEO,SAAsBD,OAAQS,WACnC,OAAOD,cAAcR,OAAQS,UAAW,GAC1C,2EAkDC"}